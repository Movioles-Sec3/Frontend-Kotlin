<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/src/HomeViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/src/HomeViewModel.kt" />
              <option name="originalContent" value="package app.src&#10;&#10;import android.app.Application&#10;import androidx.lifecycle.*&#10;import app.src.data.models.Producto&#10;import app.src.data.repositories.ProductoRepository&#10;import app.src.data.repositories.Result&#10;import app.src.utils.ImagePreloader&#10;import app.src.utils.PerformanceMetrics&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.async&#10;import android.util.Log&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.withContext&#10;import app.src.data.local.CatalogCacheManager&#10;import com.google.gson.Gson&#10;import com.google.gson.reflect.TypeToken&#10;&#10;/**&#10; * Represents the UI contract for the Home screen.&#10; *&#10; * States:&#10; * - [Loading]: Data is being fetched and the UI should show a progress indicator.&#10; * - [Success]: Data fetched successfully; contains the list of recommended products.&#10; * - [Error]: A user-facing error occurred; contains a message suitable for display.&#10; */&#10;sealed class HomeUiState {&#10;    /** Emitted while recommended products are loading. */&#10;    object Loading : HomeUiState()&#10;&#10;    /**&#10;     * Emitted when recommended products have been loaded successfully.&#10;     *&#10;     * @property productosRecomendados The list of products to render in the UI.&#10;     */&#10;    data class Success(val productosRecomendados: List&lt;Producto&gt;) : HomeUiState()&#10;&#10;    /**&#10;     * Emitted when there is an error loading data.&#10;     *&#10;     * @property message Human-readable message that can be shown to the user.&#10;     */&#10;    data class Error(val message: String) : HomeUiState()&#10;}&#10;&#10;/**&#10; * ViewModel for the Home screen.&#10; *&#10; * Responsibilities:&#10; * - Loads and exposes recommended products via [LiveData].&#10; * - Exposes a high-level UI state ([HomeUiState]) to simplify rendering logic.&#10; * - Handles user interactions originating from recommended products (e.g., item clicks).&#10; *&#10; * Lifecycle:&#10; * - Triggers an initial load of recommended products in [init].&#10; */&#10;class HomeViewModel(application: Application) : AndroidViewModel(application) {&#10;&#10;    /** Repository used to retrieve product data. */&#10;    private val productoRepository = ProductoRepository()&#10;&#10;    /** Cache manager para almacenamiento local */&#10;    private val catalogCache = CatalogCacheManager(application)&#10;    private val gson = Gson()&#10;&#10;    /**&#10;     * Backing field for the UI state.&#10;     * Use [uiState] to observe state changes from the UI layer.&#10;     */&#10;    private val _uiState = MutableLiveData&lt;HomeUiState&gt;()&#10;    val uiState: LiveData&lt;HomeUiState&gt; = _uiState&#10;&#10;    /**&#10;     * Backing field for the list of recommended products.&#10;     * Use [productosRecomendados] to observe data changes from the UI layer.&#10;     */&#10;    private val _productosRecomendados = MutableLiveData&lt;List&lt;Producto&gt;&gt;()&#10;    val productosRecomendados: LiveData&lt;List&lt;Producto&gt;&gt; = _productosRecomendados&#10;&#10;    companion object {&#10;        private const val TAG = &quot;HomeViewModel&quot;&#10;&#10;        // Flag para alternar entre carga paralela y secuencial&#10;        // En producción, esto se puede controlar con A/B testing o configuración remota&#10;        var useParallelLoading = true&#10;    }&#10;&#10;    /**&#10;     * Initializes the ViewModel by starting the initial data load.&#10;     */&#10;    init {&#10;        cargarProductosRecomendados()&#10;    }&#10;&#10;    /**&#10;     * Loads recommended products and updates both [productosRecomendados] and [uiState].&#10;     *&#10;     * Estrategia: Cache-First&#10;     * 1. Lee del caché local primero (instantáneo)&#10;     * 2. Muestra datos cacheados si existen&#10;     * 3. Actualiza desde red en background&#10;     * 4. Si no hay caché o falla la red, muestra error solo si es necesario&#10;     */&#10;    fun cargarProductosRecomendados() {&#10;        viewModelScope.launch {&#10;            _uiState.value = HomeUiState.Loading&#10;&#10;            val startTime = System.currentTimeMillis()&#10;&#10;            try {&#10;                // 1) Intentar cargar desde caché primero&#10;                val cachedData = withContext(Dispatchers.IO) {&#10;                    val cacheKey = CatalogCacheManager.KEY_HOME_RECOMMENDED&#10;                    try {&#10;                        catalogCache.getFromCache(cacheKey, Array&lt;Producto&gt;::class.java)?.toList()&#10;                    } catch (e: Exception) {&#10;                        null&#10;                    }&#10;                }&#10;&#10;                if (cachedData != null &amp;&amp; cachedData.isNotEmpty()) {&#10;                    // Mostrar datos del caché inmediatamente&#10;                    Log.d(TAG, &quot;✅ Cargando desde CACHÉ: ${cachedData.size} productos&quot;)&#10;                    val productosLimitados = cachedData.take(5)&#10;                    _productosRecomendados.value = productosLimitados&#10;                    _uiState.value = HomeUiState.Success(productosLimitados)&#10;&#10;                    // Precargar imágenes desde caché&#10;                    withContext(Dispatchers.IO) {&#10;                        val imageUrls = productosLimitados.mapNotNull { it.imagenUrl }&#10;                        if (imageUrls.isNotEmpty()) {&#10;                            ImagePreloader.preloadImagesParallel(imageUrls)&#10;                        }&#10;                    }&#10;                }&#10;&#10;                // 2) Actualizar desde red en background (sin bloquear UI)&#10;                actualizarDesdeRed(startTime, cachedData == null)&#10;&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error al cargar productos: ${e.message}&quot;)&#10;                // Solo mostrar error si no hay datos en caché&#10;                if (_productosRecomendados.value.isNullOrEmpty()) {&#10;                    _uiState.value = HomeUiState.Error(&quot;Sin conexión. Verifica tu red WiFi.&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Actualiza datos desde la red y guarda en caché&#10;     */&#10;    private suspend fun actualizarDesdeRed(startTime: Long, showLoadingIfFails: Boolean) {&#10;        withContext(Dispatchers.IO) {&#10;            try {&#10;                if (useParallelLoading) {&#10;                    cargarEnParaleloConCache(startTime)&#10;                } else {&#10;                    cargarEnSecuenciaConCache(startTime)&#10;                }&#10;                useParallelLoading = !useParallelLoading&#10;            } catch (e: Exception) {&#10;                Log.w(TAG, &quot;No se pudo actualizar desde red: ${e.message}&quot;)&#10;                // Si no hay datos en caché, mostrar error&#10;                if (showLoadingIfFails) {&#10;                    withContext(Dispatchers.Main) {&#10;                        _uiState.value = HomeUiState.Error(&quot;Sin conexión a internet&quot;)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Carga paralela: Catálogo e imágenes simultáneamente + guardar en caché&#10;     */&#10;    private suspend fun cargarEnParaleloConCache(startTime: Long) {&#10;        Log.d(TAG, &quot; Iniciando carga PARALELA&quot;)&#10;&#10;        val catalogStartTime = System.currentTimeMillis()&#10;&#10;        // 1) Launch catalog fetch in background IO thread&#10;        val catalogDeferred = viewModelScope.async(Dispatchers.IO) {&#10;            productoRepository.obtenerProductosRecomendados(getApplication&lt;Application&gt;())&#10;        }&#10;&#10;        // 2) Wait for catalog (back on main after await)&#10;        when (val result = catalogDeferred.await()) {&#10;            is Result.Success -&gt; {&#10;                val catalogLoadTime = System.currentTimeMillis() - catalogStartTime&#10;                val productosLimitados = result.data.take(5)&#10;&#10;                // Guardar en caché&#10;                withContext(Dispatchers.IO) {&#10;                    val cacheKey = CatalogCacheManager.KEY_HOME_RECOMMENDED&#10;                    catalogCache.saveToCache(&#10;                        cacheKey,&#10;                        result.data,&#10;                        CatalogCacheManager.TTL_RECOMMENDED&#10;                    )&#10;                }&#10;&#10;                val imageStartTime = System.currentTimeMillis()&#10;                val imageUrls = productosLimitados.mapNotNull { it.imagenUrl }&#10;&#10;                val imagesDeferred = viewModelScope.async(Dispatchers.IO) {&#10;                    if (imageUrls.isNotEmpty()) {&#10;                        ImagePreloader.preloadImagesParallel(imageUrls)&#10;                    } else {&#10;                        0L&#10;                    }&#10;                }&#10;&#10;                withContext(Dispatchers.Main) {&#10;                    _productosRecomendados.value = productosLimitados&#10;                    _uiState.value = HomeUiState.Success(productosLimitados)&#10;                }&#10;&#10;                val imagesLoadTime = imagesDeferred.await()&#10;                val totalTime = System.currentTimeMillis() - startTime&#10;                val menuReadyTime = totalTime&#10;&#10;                registrarMetricas(&#10;                    loadType = PerformanceMetrics.LoadType.PARALLEL,&#10;                    catalogLoadTime = catalogLoadTime,&#10;                    imagesLoadTime = imagesLoadTime,&#10;                    totalTime = totalTime,&#10;                    menuReadyTime = menuReadyTime,&#10;                    productCount = productosLimitados.size&#10;                )&#10;&#10;                Log.d(TAG, &quot;✅ Carga PARALELA desde RED completada y guardada en caché&quot;)&#10;            }&#10;            is Result.Error -&gt; {&#10;                Log.w(TAG, &quot;Error al actualizar desde red: ${result.message}&quot;)&#10;            }&#10;            else -&gt; {&#10;                Log.w(TAG, &quot;Resultado desconocido al actualizar desde red&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Carga secuencial: Catálogo primero, luego imágenes + guardar en caché&#10;     */&#10;    private suspend fun cargarEnSecuenciaConCache(startTime: Long) {&#10;        Log.d(TAG, &quot; Iniciando carga SECUENCIAL&quot;)&#10;&#10;        val catalogStartTime = System.currentTimeMillis()&#10;&#10;        // 1) fetch catalog on IO&#10;        val result = withContext(Dispatchers.IO) {&#10;            productoRepository.obtenerProductosRecomendados(getApplication&lt;Application&gt;())&#10;        }&#10;&#10;        when (result) {&#10;            is Result.Success -&gt; {&#10;                val catalogLoadTime = System.currentTimeMillis() - catalogStartTime&#10;                val productosLimitados = result.data.take(5)&#10;&#10;                // Guardar en caché&#10;                withContext(Dispatchers.IO) {&#10;                    val cacheKey = CatalogCacheManager.KEY_HOME_RECOMMENDED&#10;                    catalogCache.saveToCache(&#10;                        cacheKey,&#10;                        result.data,&#10;                        CatalogCacheManager.TTL_RECOMMENDED&#10;                    )&#10;                }&#10;&#10;                withContext(Dispatchers.Main) {&#10;                    _productosRecomendados.value = productosLimitados&#10;                    _uiState.value = HomeUiState.Success(productosLimitados)&#10;                }&#10;&#10;                val imageStartTime = System.currentTimeMillis()&#10;                val imageUrls = productosLimitados.mapNotNull { it.imagenUrl }&#10;                val imagesLoadTime = if (imageUrls.isNotEmpty()) {&#10;                    ImagePreloader.preloadImagesParallel(imageUrls)&#10;                } else {&#10;                    0L&#10;                }&#10;&#10;                val totalTime = System.currentTimeMillis() - startTime&#10;                val menuReadyTime = totalTime&#10;&#10;                registrarMetricas(&#10;                    loadType = PerformanceMetrics.LoadType.SEQUENTIAL,&#10;                    catalogLoadTime = catalogLoadTime,&#10;                    imagesLoadTime = imagesLoadTime,&#10;                    totalTime = totalTime,&#10;                    menuReadyTime = menuReadyTime,&#10;                    productCount = productosLimitados.size&#10;                )&#10;&#10;                Log.d(TAG, &quot;✅ Carga SECUENCIAL desde RED completada y guardada en caché&quot;)&#10;            }&#10;            is Result.Error -&gt; {&#10;                Log.w(TAG, &quot;Error al actualizar desde red: ${result.message}&quot;)&#10;            }&#10;            else -&gt; {&#10;                Log.w(TAG, &quot;Resultado desconocido al actualizar desde red&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Registra métricas de rendimiento&#10;     */&#10;    private suspend fun registrarMetricas(&#10;        loadType: PerformanceMetrics.LoadType,&#10;        catalogLoadTime: Long,&#10;        imagesLoadTime: Long,&#10;        totalTime: Long,&#10;        menuReadyTime: Long,&#10;        productCount: Int&#10;    ) {&#10;        val context = getApplication&lt;Application&gt;()&#10;        val networkType = getNetworkType()&#10;        val deviceTier = getDeviceTier()&#10;&#10;        PerformanceMetrics.recordMeasurement(&#10;            context = context,&#10;            loadType = loadType,&#10;            catalogLoadTime = catalogLoadTime,&#10;            imagesLoadTime = imagesLoadTime,&#10;            totalTime = totalTime,&#10;            menuReadyTime = menuReadyTime,&#10;            productCount = productCount,&#10;            networkType = networkType,&#10;            deviceTier = deviceTier&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Obtiene el tipo de red actual&#10;     */&#10;    private fun getNetworkType(): String {&#10;        val context = getApplication&lt;Application&gt;()&#10;        val cm = context.getSystemService(android.content.Context.CONNECTIVITY_SERVICE) as android.net.ConnectivityManager&#10;        val network = cm.activeNetwork ?: return &quot;Offline&quot;&#10;        val capabilities = cm.getNetworkCapabilities(network) ?: return &quot;Unknown&quot;&#10;&#10;        return when {&#10;            capabilities.hasTransport(android.net.NetworkCapabilities.TRANSPORT_WIFI) -&gt; &quot;Wi-Fi&quot;&#10;            capabilities.hasTransport(android.net.NetworkCapabilities.TRANSPORT_CELLULAR) -&gt; &quot;Cellular&quot;&#10;            else -&gt; &quot;Unknown&quot;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Obtiene el tier del dispositivo&#10;     */&#10;    private fun getDeviceTier(): String {&#10;        val ram = Runtime.getRuntime().maxMemory() / (1024 * 1024)&#10;        return when {&#10;            ram &lt; 2000 -&gt; &quot;low&quot;&#10;            ram &lt; 4000 -&gt; &quot;mid&quot;&#10;            else -&gt; &quot;high&quot;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Handles clicks on a recommended product.&#10;     *&#10;     * Extend this to:&#10;     * - Send analytics events.&#10;     * - Navigate to a product detail screen.&#10;     * - Preload images or additional data for a smoother transition.&#10;     *&#10;     * @param producto The product that was clicked.&#10;     */&#10;    fun onProductoRecomendadoClick(producto: Producto) {&#10;        // Aquí podrías agregar lógica adicional si es necesario&#10;        // Por ejemplo, analytics, tracking, etc.&#10;    }&#10;}" />
              <option name="updatedContent" value="package app.src&#10;&#10;import android.app.Application&#10;import androidx.lifecycle.*&#10;import app.src.data.models.Producto&#10;import app.src.data.repositories.ProductoRepository&#10;import app.src.data.repositories.Result&#10;import app.src.utils.ImagePreloader&#10;import app.src.utils.PerformanceMetrics&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.async&#10;import android.util.Log&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.withContext&#10;import app.src.data.local.CatalogCacheManager&#10;import com.google.gson.Gson&#10;import com.google.gson.reflect.TypeToken&#10;&#10;/**&#10; * Represents the UI contract for the Home screen.&#10; *&#10; * States:&#10; * - [Loading]: Data is being fetched and the UI should show a progress indicator.&#10; * - [Success]: Data fetched successfully; contains the list of recommended products.&#10; * - [Error]: A user-facing error occurred; contains a message suitable for display.&#10; */&#10;sealed class HomeUiState {&#10;    /** Emitted while recommended products are loading. */&#10;    object Loading : HomeUiState()&#10;&#10;    /**&#10;     * Emitted when recommended products have been loaded successfully.&#10;     *&#10;     * @property productosRecomendados The list of products to render in the UI.&#10;     */&#10;    data class Success(val productosRecomendados: List&lt;Producto&gt;) : HomeUiState()&#10;&#10;    /**&#10;     * Emitted when there is an error loading data.&#10;     *&#10;     * @property message Human-readable message that can be shown to the user.&#10;     */&#10;    data class Error(val message: String) : HomeUiState()&#10;}&#10;&#10;/**&#10; * ViewModel for the Home screen.&#10; *&#10; * Responsibilities:&#10; * - Loads and exposes recommended products via [LiveData].&#10; * - Exposes a high-level UI state ([HomeUiState]) to simplify rendering logic.&#10; * - Handles user interactions originating from recommended products (e.g., item clicks).&#10; *&#10; * Lifecycle:&#10; * - Triggers an initial load of recommended products in [init].&#10; */&#10;class HomeViewModel(application: Application) : AndroidViewModel(application) {&#10;&#10;    /** Repository used to retrieve product data. */&#10;    private val productoRepository = ProductoRepository()&#10;&#10;    /** Cache manager para almacenamiento local */&#10;    private val catalogCache = CatalogCacheManager(application)&#10;    private val gson = Gson()&#10;&#10;    /**&#10;     * Backing field for the UI state.&#10;     * Use [uiState] to observe state changes from the UI layer.&#10;     */&#10;    private val _uiState = MutableLiveData&lt;HomeUiState&gt;()&#10;    val uiState: LiveData&lt;HomeUiState&gt; = _uiState&#10;&#10;    /**&#10;     * Backing field for the list of recommended products.&#10;     * Use [productosRecomendados] to observe data changes from the UI layer.&#10;     */&#10;    private val _productosRecomendados = MutableLiveData&lt;List&lt;Producto&gt;&gt;()&#10;    val productosRecomendados: LiveData&lt;List&lt;Producto&gt;&gt; = _productosRecomendados&#10;&#10;    companion object {&#10;        private const val TAG = &quot;HomeViewModel&quot;&#10;&#10;        // Flag para alternar entre carga paralela y secuencial&#10;        // En producción, esto se puede controlar con A/B testing o configuración remota&#10;        var useParallelLoading = true&#10;    }&#10;&#10;    /**&#10;     * Initializes the ViewModel by starting the initial data load.&#10;     */&#10;    init {&#10;        cargarProductosRecomendados()&#10;    }&#10;&#10;    /**&#10;     * Loads recommended products and updates both [productosRecomendados] and [uiState].&#10;     *&#10;     * Estrategia: Cache-First&#10;     * 1. Lee del caché local primero (instantáneo)&#10;     * 2. Muestra datos cacheados si existen&#10;     * 3. Actualiza desde red en background&#10;     * 4. Si no hay caché o falla la red, muestra error solo si es necesario&#10;     */&#10;    fun cargarProductosRecomendados() {&#10;        viewModelScope.launch {&#10;            _uiState.value = HomeUiState.Loading&#10;&#10;            val startTime = System.currentTimeMillis()&#10;&#10;            try {&#10;                // 1) Intentar cargar desde caché primero&#10;                val cachedData = withContext(Dispatchers.IO) {&#10;                    val cacheKey = CatalogCacheManager.KEY_HOME_RECOMMENDED&#10;                    try {&#10;                        catalogCache.getFromCache(cacheKey, Array&lt;Producto&gt;::class.java)?.toList()&#10;                    } catch (e: Exception) {&#10;                        null&#10;                    }&#10;                }&#10;&#10;                if (cachedData != null &amp;&amp; cachedData.isNotEmpty()) {&#10;                    // Mostrar datos del caché inmediatamente&#10;                    Log.d(TAG, &quot;✅ Cargando desde CACHÉ: ${cachedData.size} productos&quot;)&#10;                    val productosLimitados = cachedData.take(5)&#10;                    _productosRecomendados.value = productosLimitados&#10;                    _uiState.value = HomeUiState.Success(productosLimitados)&#10;&#10;                    // Precargar imágenes desde caché&#10;                    withContext(Dispatchers.IO) {&#10;                        val imageUrls = productosLimitados.mapNotNull { it.imagenUrl }&#10;                        if (imageUrls.isNotEmpty()) {&#10;                            ImagePreloader.preloadImagesParallel(imageUrls)&#10;                        }&#10;                    }&#10;                }&#10;&#10;                // 2) Actualizar desde red en background (sin bloquear UI)&#10;                actualizarDesdeRed(startTime, cachedData == null)&#10;&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error al cargar productos: ${e.message}&quot;)&#10;                // Solo mostrar error si no hay datos en caché&#10;                if (_productosRecomendados.value.isNullOrEmpty()) {&#10;                    _uiState.value = HomeUiState.Error(&quot;Sin conexión. Verifica tu red WiFi.&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Actualiza datos desde la red y guarda en caché&#10;     */&#10;    private suspend fun actualizarDesdeRed(startTime: Long, showLoadingIfFails: Boolean) {&#10;        withContext(Dispatchers.IO) {&#10;            try {&#10;                if (useParallelLoading) {&#10;                    cargarEnParaleloConCache(startTime)&#10;                } else {&#10;                    cargarEnSecuenciaConCache(startTime)&#10;                }&#10;                useParallelLoading = !useParallelLoading&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;❌ Error actualizando desde red: ${e.javaClass.simpleName}: ${e.message}&quot;)&#10;                e.printStackTrace()&#10;                &#10;                // Si no hay datos en caché, mostrar error con mensaje más descriptivo&#10;                if (showLoadingIfFails &amp;&amp; _productosRecomendados.value.isNullOrEmpty()) {&#10;                    withContext(Dispatchers.Main) {&#10;                        val errorMessage = when {&#10;                            e.message?.contains(&quot;failed to connect&quot;, ignoreCase = true) == true -&gt;&#10;                                &quot;Servidor no disponible. Verifica que el backend esté funcionando en 192.168.0.9:8080&quot;&#10;                            e.message?.contains(&quot;timeout&quot;, ignoreCase = true) == true -&gt;&#10;                                &quot;Tiempo de espera agotado. El servidor tardó mucho en responder.&quot;&#10;                            else -&gt;&#10;                                &quot;Error al cargar productos: ${e.message}&quot;&#10;                        }&#10;                        _uiState.value = HomeUiState.Error(errorMessage)&#10;                    }&#10;                } else {&#10;                    Log.d(TAG, &quot;⚠️ Error de red ignorado porque hay datos en caché disponibles&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Carga paralela: Catálogo e imágenes simultáneamente + guardar en caché&#10;     */&#10;    private suspend fun cargarEnParaleloConCache(startTime: Long) {&#10;        Log.d(TAG, &quot; Iniciando carga PARALELA&quot;)&#10;&#10;        val catalogStartTime = System.currentTimeMillis()&#10;&#10;        // 1) Launch catalog fetch in background IO thread&#10;        val catalogDeferred = viewModelScope.async(Dispatchers.IO) {&#10;            productoRepository.obtenerProductosRecomendados(getApplication&lt;Application&gt;())&#10;        }&#10;&#10;        // 2) Wait for catalog (back on main after await)&#10;        when (val result = catalogDeferred.await()) {&#10;            is Result.Success -&gt; {&#10;                val catalogLoadTime = System.currentTimeMillis() - catalogStartTime&#10;                val productosLimitados = result.data.take(5)&#10;&#10;                // Guardar en caché&#10;                withContext(Dispatchers.IO) {&#10;                    val cacheKey = CatalogCacheManager.KEY_HOME_RECOMMENDED&#10;                    catalogCache.saveToCache(&#10;                        cacheKey,&#10;                        result.data,&#10;                        CatalogCacheManager.TTL_RECOMMENDED&#10;                    )&#10;                }&#10;&#10;                val imageStartTime = System.currentTimeMillis()&#10;                val imageUrls = productosLimitados.mapNotNull { it.imagenUrl }&#10;&#10;                val imagesDeferred = viewModelScope.async(Dispatchers.IO) {&#10;                    if (imageUrls.isNotEmpty()) {&#10;                        ImagePreloader.preloadImagesParallel(imageUrls)&#10;                    } else {&#10;                        0L&#10;                    }&#10;                }&#10;&#10;                withContext(Dispatchers.Main) {&#10;                    _productosRecomendados.value = productosLimitados&#10;                    _uiState.value = HomeUiState.Success(productosLimitados)&#10;                }&#10;&#10;                val imagesLoadTime = imagesDeferred.await()&#10;                val totalTime = System.currentTimeMillis() - startTime&#10;                val menuReadyTime = totalTime&#10;&#10;                registrarMetricas(&#10;                    loadType = PerformanceMetrics.LoadType.PARALLEL,&#10;                    catalogLoadTime = catalogLoadTime,&#10;                    imagesLoadTime = imagesLoadTime,&#10;                    totalTime = totalTime,&#10;                    menuReadyTime = menuReadyTime,&#10;                    productCount = productosLimitados.size&#10;                )&#10;&#10;                Log.d(TAG, &quot;✅ Carga PARALELA desde RED completada y guardada en caché&quot;)&#10;            }&#10;            is Result.Error -&gt; {&#10;                Log.w(TAG, &quot;Error al actualizar desde red: ${result.message}&quot;)&#10;            }&#10;            else -&gt; {&#10;                Log.w(TAG, &quot;Resultado desconocido al actualizar desde red&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Carga secuencial: Catálogo primero, luego imágenes + guardar en caché&#10;     */&#10;    private suspend fun cargarEnSecuenciaConCache(startTime: Long) {&#10;        Log.d(TAG, &quot; Iniciando carga SECUENCIAL&quot;)&#10;&#10;        val catalogStartTime = System.currentTimeMillis()&#10;&#10;        // 1) fetch catalog on IO&#10;        val result = withContext(Dispatchers.IO) {&#10;            productoRepository.obtenerProductosRecomendados(getApplication&lt;Application&gt;())&#10;        }&#10;&#10;        when (result) {&#10;            is Result.Success -&gt; {&#10;                val catalogLoadTime = System.currentTimeMillis() - catalogStartTime&#10;                val productosLimitados = result.data.take(5)&#10;&#10;                // Guardar en caché&#10;                withContext(Dispatchers.IO) {&#10;                    val cacheKey = CatalogCacheManager.KEY_HOME_RECOMMENDED&#10;                    catalogCache.saveToCache(&#10;                        cacheKey,&#10;                        result.data,&#10;                        CatalogCacheManager.TTL_RECOMMENDED&#10;                    )&#10;                }&#10;&#10;                withContext(Dispatchers.Main) {&#10;                    _productosRecomendados.value = productosLimitados&#10;                    _uiState.value = HomeUiState.Success(productosLimitados)&#10;                }&#10;&#10;                val imageStartTime = System.currentTimeMillis()&#10;                val imageUrls = productosLimitados.mapNotNull { it.imagenUrl }&#10;                val imagesLoadTime = if (imageUrls.isNotEmpty()) {&#10;                    ImagePreloader.preloadImagesParallel(imageUrls)&#10;                } else {&#10;                    0L&#10;                }&#10;&#10;                val totalTime = System.currentTimeMillis() - startTime&#10;                val menuReadyTime = totalTime&#10;&#10;                registrarMetricas(&#10;                    loadType = PerformanceMetrics.LoadType.SEQUENTIAL,&#10;                    catalogLoadTime = catalogLoadTime,&#10;                    imagesLoadTime = imagesLoadTime,&#10;                    totalTime = totalTime,&#10;                    menuReadyTime = menuReadyTime,&#10;                    productCount = productosLimitados.size&#10;                )&#10;&#10;                Log.d(TAG, &quot;✅ Carga SECUENCIAL desde RED completada y guardada en caché&quot;)&#10;            }&#10;            is Result.Error -&gt; {&#10;                Log.w(TAG, &quot;Error al actualizar desde red: ${result.message}&quot;)&#10;            }&#10;            else -&gt; {&#10;                Log.w(TAG, &quot;Resultado desconocido al actualizar desde red&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Registra métricas de rendimiento&#10;     */&#10;    private suspend fun registrarMetricas(&#10;        loadType: PerformanceMetrics.LoadType,&#10;        catalogLoadTime: Long,&#10;        imagesLoadTime: Long,&#10;        totalTime: Long,&#10;        menuReadyTime: Long,&#10;        productCount: Int&#10;    ) {&#10;        val context = getApplication&lt;Application&gt;()&#10;        val networkType = getNetworkType()&#10;        val deviceTier = getDeviceTier()&#10;&#10;        PerformanceMetrics.recordMeasurement(&#10;            context = context,&#10;            loadType = loadType,&#10;            catalogLoadTime = catalogLoadTime,&#10;            imagesLoadTime = imagesLoadTime,&#10;            totalTime = totalTime,&#10;            menuReadyTime = menuReadyTime,&#10;            productCount = productCount,&#10;            networkType = networkType,&#10;            deviceTier = deviceTier&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Obtiene el tipo de red actual&#10;     */&#10;    private fun getNetworkType(): String {&#10;        val context = getApplication&lt;Application&gt;()&#10;        val cm = context.getSystemService(android.content.Context.CONNECTIVITY_SERVICE) as android.net.ConnectivityManager&#10;        val network = cm.activeNetwork ?: return &quot;Offline&quot;&#10;        val capabilities = cm.getNetworkCapabilities(network) ?: return &quot;Unknown&quot;&#10;&#10;        return when {&#10;            capabilities.hasTransport(android.net.NetworkCapabilities.TRANSPORT_WIFI) -&gt; &quot;Wi-Fi&quot;&#10;            capabilities.hasTransport(android.net.NetworkCapabilities.TRANSPORT_CELLULAR) -&gt; &quot;Cellular&quot;&#10;            else -&gt; &quot;Unknown&quot;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Obtiene el tier del dispositivo&#10;     */&#10;    private fun getDeviceTier(): String {&#10;        val ram = Runtime.getRuntime().maxMemory() / (1024 * 1024)&#10;        return when {&#10;            ram &lt; 2000 -&gt; &quot;low&quot;&#10;            ram &lt; 4000 -&gt; &quot;mid&quot;&#10;            else -&gt; &quot;high&quot;&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Handles clicks on a recommended product.&#10;     *&#10;     * Extend this to:&#10;     * - Send analytics events.&#10;     * - Navigate to a product detail screen.&#10;     * - Preload images or additional data for a smoother transition.&#10;     *&#10;     * @param producto The product that was clicked.&#10;     */&#10;    fun onProductoRecomendadoClick(producto: Producto) {&#10;        // Aquí podrías agregar lógica adicional si es necesario&#10;        // Por ejemplo, analytics, tracking, etc.&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/src/LoginActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/src/LoginActivity.kt" />
              <option name="originalContent" value="package app.src&#10;&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import android.text.Editable&#10;import android.text.TextWatcher&#10;import android.view.inputmethod.EditorInfo&#10;import android.widget.Toast&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.activity.viewModels&#10;import androidx.core.view.isVisible&#10;import androidx.lifecycle.lifecycleScope&#10;import app.src.databinding.ActivityLoginBinding&#10;import app.src.data.api.ApiClient&#10;import app.src.data.repositories.UsuarioRepository&#10;import app.src.data.repositories.Result&#10;import app.src.utils.SessionManager&#10;import app.src.utils.NetworkUtils&#10;import kotlinx.coroutines.launch&#10;&#10;class LoginActivity : BaseActivity() {&#10;&#10;    private lateinit var binding: ActivityLoginBinding&#10;    private val vm: LoginViewModel by viewModels {&#10;        LoginViewModel.factory(AuthRepository())&#10;    }&#10;    private val usuarioRepo = UsuarioRepository()&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        enableEdgeToEdge()&#10;        super.onCreate(savedInstanceState)&#10;&#10;        // Verificar si ya hay sesión activa&#10;        if (SessionManager.isLoggedIn(this)) {&#10;            val token = SessionManager.getToken(this)&#10;            ApiClient.setToken(token)&#10;            navigateToHome()&#10;            return&#10;        }&#10;&#10;        binding = ActivityLoginBinding.inflate(layoutInflater)&#10;        setContentView(binding.root)&#10;&#10;        // Accesibilidad básica&#10;        binding.btnLogin.contentDescription = getString(R.string.cd_login_button)&#10;&#10;        // Listeners&#10;        binding.etUsername.addTextChangedListener(fieldWatcher { vm.onUserChanged(it) })&#10;        binding.etPassword.addTextChangedListener(fieldWatcher { vm.onPassChanged(it) })&#10;&#10;        binding.etPassword.setOnEditorActionListener { _, actionId, _ -&gt;&#10;            if (actionId == EditorInfo.IME_ACTION_DONE &amp;&amp; binding.btnLogin.isEnabled) {&#10;                attemptLogin()&#10;                true&#10;            } else false&#10;        }&#10;&#10;        binding.btnLogin.setOnClickListener { attemptLogin() }&#10;&#10;        // Botón para ir a registro&#10;        binding.btnRegister.setOnClickListener {&#10;            startActivity(Intent(this, RegisterActivity::class.java))&#10;        }&#10;&#10;        // Observers&#10;        vm.uiState.observe(this) { state -&gt;&#10;            binding.progress.isVisible = state is LoginUiState.Loading&#10;            binding.btnLogin.isEnabled = state !is LoginUiState.Loading&#10;&#10;            when (state) {&#10;                is LoginUiState.Idle -&gt; Unit&#10;                is LoginUiState.Loading -&gt; Unit&#10;                is LoginUiState.Error -&gt; {&#10;                    // Muestra errores de formulario si aplica&#10;                    binding.tilUsername.error = state.userError?.let { getString(it) }&#10;                    binding.tilPassword.error = state.passError?.let { getString(it) }&#10;                    if (state.message != null) {&#10;                        Toast.makeText(this, getString(state.message), Toast.LENGTH_SHORT).show()&#10;                    }&#10;                }&#10;                is LoginUiState.Success -&gt; {&#10;                    // Guardar token y obtener datos del usuario&#10;                    val token = ApiClient.getToken()&#10;                    if (token != null) {&#10;                        SessionManager.saveToken(this, token)&#10;                        obtenerDatosUsuario()&#10;                    } else {&#10;                        navigateToHome()&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun attemptLogin() {&#10;        // ✅ VALIDAR CONEXIÓN A INTERNET ANTES DE INTENTAR LOGIN&#10;        if (!NetworkUtils.isNetworkAvailable(this)) {&#10;            Toast.makeText(&#10;                this,&#10;                &quot;No internet connection. Please check your network and try again.&quot;,&#10;                Toast.LENGTH_LONG&#10;            ).show()&#10;            return&#10;        }&#10;&#10;        binding.tilUsername.error = null&#10;        binding.tilPassword.error = null&#10;        vm.login()&#10;    }&#10;&#10;    private fun obtenerDatosUsuario() {&#10;        lifecycleScope.launch {&#10;            when (val result = usuarioRepo.obtenerPerfil()) {&#10;                is Result.Success -&gt; {&#10;                    val usuario = result.data&#10;                    SessionManager.saveUserData(&#10;                        this@LoginActivity,&#10;                        usuario.id,&#10;                        usuario.nombre,&#10;                        usuario.email,&#10;                        usuario.saldo&#10;                    )&#10;&#10;                    // ✅ GUARDAR userId EN DATASTORE PARA ROOM&#10;                    val dataStore = app.src.data.local.DataStoreManager(this@LoginActivity)&#10;                    dataStore.saveUserId(usuario.id)&#10;&#10;                    navigateToHome()&#10;                }&#10;                else -&gt; {&#10;                    // Si falla obtener perfil, igual navegamos&#10;                    navigateToHome()&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun navigateToHome() {&#10;        startActivity(Intent(this, HomeActivity::class.java))&#10;        finish()&#10;    }&#10;&#10;    private fun fieldWatcher(onChange: (String) -&gt; Unit) = object : TextWatcher {&#10;        override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {}&#10;        override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {&#10;            onChange(s?.toString().orEmpty())&#10;        }&#10;        override fun afterTextChanged(s: Editable?) {}&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package app.src&#10;&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import android.text.Editable&#10;import android.text.TextWatcher&#10;import android.view.inputmethod.EditorInfo&#10;import android.widget.Toast&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.activity.viewModels&#10;import androidx.core.view.isVisible&#10;import androidx.lifecycle.lifecycleScope&#10;import app.src.databinding.ActivityLoginBinding&#10;import app.src.data.api.ApiClient&#10;import app.src.data.repositories.UsuarioRepository&#10;import app.src.data.repositories.Result&#10;import app.src.utils.SessionManager&#10;import app.src.utils.NetworkUtils&#10;import kotlinx.coroutines.launch&#10;&#10;class LoginActivity : BaseActivity() {&#10;&#10;    private lateinit var binding: ActivityLoginBinding&#10;    private val vm: LoginViewModel by viewModels {&#10;        LoginViewModel.factory(AuthRepository())&#10;    }&#10;    private val usuarioRepo = UsuarioRepository()&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        enableEdgeToEdge()&#10;        super.onCreate(savedInstanceState)&#10;&#10;        // Verificar si ya hay sesión activa&#10;        if (SessionManager.isLoggedIn(this)) {&#10;            val token = SessionManager.getToken(this)&#10;            ApiClient.setToken(token)&#10;            navigateToHome()&#10;            return&#10;        }&#10;&#10;        binding = ActivityLoginBinding.inflate(layoutInflater)&#10;        setContentView(binding.root)&#10;&#10;        // Accesibilidad básica&#10;        binding.btnLogin.contentDescription = getString(R.string.cd_login_button)&#10;&#10;        // Listeners&#10;        binding.etUsername.addTextChangedListener(fieldWatcher { vm.onUserChanged(it) })&#10;        binding.etPassword.addTextChangedListener(fieldWatcher { vm.onPassChanged(it) })&#10;&#10;        binding.etPassword.setOnEditorActionListener { _, actionId, _ -&gt;&#10;            if (actionId == EditorInfo.IME_ACTION_DONE &amp;&amp; binding.btnLogin.isEnabled) {&#10;                attemptLogin()&#10;                true&#10;            } else false&#10;        }&#10;&#10;        binding.btnLogin.setOnClickListener { attemptLogin() }&#10;&#10;        // Botón para ir a registro&#10;        binding.btnRegister.setOnClickListener {&#10;            startActivity(Intent(this, RegisterActivity::class.java))&#10;        }&#10;&#10;        // Observers&#10;        vm.uiState.observe(this) { state -&gt;&#10;            binding.progress.isVisible = state is LoginUiState.Loading&#10;            binding.btnLogin.isEnabled = state !is LoginUiState.Loading&#10;&#10;            when (state) {&#10;                is LoginUiState.Idle -&gt; Unit&#10;                is LoginUiState.Loading -&gt; Unit&#10;                is LoginUiState.Error -&gt; {&#10;                    // Muestra errores de formulario si aplica&#10;                    binding.tilUsername.error = state.userError?.let { getString(it) }&#10;                    binding.tilPassword.error = state.passError?.let { getString(it) }&#10;                    &#10;                    // ✅ MOSTRAR MENSAJE PERSONALIZADO O MENSAJE DE RECURSO&#10;                    val errorMessage = state.customMessage ?: state.message?.let { getString(it) }&#10;                    if (errorMessage != null) {&#10;                        Toast.makeText(this, errorMessage, Toast.LENGTH_LONG).show()&#10;                    }&#10;                }&#10;                is LoginUiState.Success -&gt; {&#10;                    // Guardar token y obtener datos del usuario&#10;                    val token = ApiClient.getToken()&#10;                    if (token != null) {&#10;                        SessionManager.saveToken(this, token)&#10;                        obtenerDatosUsuario()&#10;                    } else {&#10;                        navigateToHome()&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun attemptLogin() {&#10;        // ✅ NO BLOQUEAR EL LOGIN - Dejar que intente conectar y manejar errores después&#10;        binding.tilUsername.error = null&#10;        binding.tilPassword.error = null&#10;        vm.login()&#10;    }&#10;&#10;    private fun obtenerDatosUsuario() {&#10;        lifecycleScope.launch {&#10;            when (val result = usuarioRepo.obtenerPerfil()) {&#10;                is Result.Success -&gt; {&#10;                    val usuario = result.data&#10;                    SessionManager.saveUserData(&#10;                        this@LoginActivity,&#10;                        usuario.id,&#10;                        usuario.nombre,&#10;                        usuario.email,&#10;                        usuario.saldo&#10;                    )&#10;&#10;                    // ✅ GUARDAR userId EN DATASTORE PARA ROOM&#10;                    val dataStore = app.src.data.local.DataStoreManager(this@LoginActivity)&#10;                    dataStore.saveUserId(usuario.id)&#10;&#10;                    navigateToHome()&#10;                }&#10;                else -&gt; {&#10;                    // Si falla obtener perfil, igual navegamos&#10;                    navigateToHome()&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun navigateToHome() {&#10;        startActivity(Intent(this, HomeActivity::class.java))&#10;        finish()&#10;    }&#10;&#10;    private fun fieldWatcher(onChange: (String) -&gt; Unit) = object : TextWatcher {&#10;        override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {}&#10;        override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) {&#10;            onChange(s?.toString().orEmpty())&#10;        }&#10;        override fun afterTextChanged(s: Editable?) {}&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/src/LoginViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/src/LoginViewModel.kt" />
              <option name="originalContent" value="package app.src&#10;&#10;import androidx.annotation.StringRes&#10;import androidx.lifecycle.*&#10;import app.src.data.repositories.Result&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.launch&#10;&#10;sealed class LoginUiState {&#10;    object Idle : LoginUiState()&#10;    object Loading : LoginUiState()&#10;    data class Error(&#10;        @StringRes val message: Int? = null,&#10;        @StringRes val userError: Int? = null,&#10;        @StringRes val passError: Int? = null&#10;    ) : LoginUiState()&#10;    object Success : LoginUiState()&#10;}&#10;&#10;class LoginViewModel(private val repo: AuthRepository) : ViewModel() {&#10;&#10;    private val _uiState = MutableLiveData&lt;LoginUiState&gt;(LoginUiState.Idle)&#10;    val uiState: LiveData&lt;LoginUiState&gt; = _uiState&#10;&#10;    private var user: String = &quot;&quot;&#10;    private var pass: String = &quot;&quot;&#10;&#10;    fun onUserChanged(value: String) { user = value }&#10;    fun onPassChanged(value: String) { pass = value }&#10;&#10;    fun login() {&#10;        // Validación local&#10;        val uErr = if (user.isBlank()) R.string.err_user_required else null&#10;        val pErr = if (pass.length &lt; 6) R.string.err_pass_min else null&#10;        if (uErr != null || pErr != null) {&#10;            _uiState.value = LoginUiState.Error(userError = uErr, passError = pErr)&#10;            return&#10;        }&#10;&#10;        viewModelScope.launch(Dispatchers.IO) {&#10;            _uiState.postValue(LoginUiState.Loading)&#10;&#10;            when (val result = repo.login(user, pass)) {&#10;                is Result.Success -&gt; {&#10;                    _uiState.postValue(LoginUiState.Success)&#10;                }&#10;                is Result.Error -&gt; {&#10;                    _uiState.postValue(LoginUiState.Error(message = R.string.err_bad_credentials))&#10;                }&#10;                else -&gt; {&#10;                    _uiState.postValue(LoginUiState.Error(message = R.string.err_bad_credentials))&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    companion object {&#10;        fun factory(repo: AuthRepository) = object : ViewModelProvider.Factory {&#10;            @Suppress(&quot;UNCHECKED_CAST&quot;)&#10;            override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T {&#10;                return LoginViewModel(repo) as T&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package app.src&#10;&#10;import androidx.annotation.StringRes&#10;import androidx.lifecycle.*&#10;import app.src.data.repositories.Result&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.launch&#10;&#10;sealed class LoginUiState {&#10;    object Idle : LoginUiState()&#10;    object Loading : LoginUiState()&#10;    data class Error(&#10;        @StringRes val message: Int? = null,&#10;        val customMessage: String? = null, // ✅ NUEVO: Para mensajes personalizados&#10;        @StringRes val userError: Int? = null,&#10;        @StringRes val passError: Int? = null&#10;    ) : LoginUiState()&#10;    object Success : LoginUiState()&#10;}&#10;&#10;class LoginViewModel(private val repo: AuthRepository) : ViewModel() {&#10;&#10;    private val _uiState = MutableLiveData&lt;LoginUiState&gt;(LoginUiState.Idle)&#10;    val uiState: LiveData&lt;LoginUiState&gt; = _uiState&#10;&#10;    private var user: String = &quot;&quot;&#10;    private var pass: String = &quot;&quot;&#10;&#10;    fun onUserChanged(value: String) { user = value }&#10;    fun onPassChanged(value: String) { pass = value }&#10;&#10;    fun login() {&#10;        // Validación local&#10;        val uErr = if (user.isBlank()) R.string.err_user_required else null&#10;        val pErr = if (pass.length &lt; 6) R.string.err_pass_min else null&#10;        if (uErr != null || pErr != null) {&#10;            _uiState.value = LoginUiState.Error(userError = uErr, passError = pErr)&#10;            return&#10;        }&#10;&#10;        viewModelScope.launch(Dispatchers.IO) {&#10;            _uiState.postValue(LoginUiState.Loading)&#10;&#10;            when (val result = repo.login(user, pass)) {&#10;                is Result.Success -&gt; {&#10;                    _uiState.postValue(LoginUiState.Success)&#10;                }&#10;                is Result.Error -&gt; {&#10;                    // ✅ MOSTRAR MENSAJE PERSONALIZADO DEL ERROR&#10;                    val errorMsg = result.message&#10;                    if (errorMsg.contains(&quot;Servidor no disponible&quot;, ignoreCase = true) ||&#10;                        errorMsg.contains(&quot;failed to connect&quot;, ignoreCase = true)) {&#10;                        // Error de servidor no disponible&#10;                        _uiState.postValue(LoginUiState.Error(customMessage = errorMsg))&#10;                    } else if (errorMsg.contains(&quot;Credenciales&quot;, ignoreCase = true) || &#10;                               result.code == 401) {&#10;                        // Error de credenciales incorrectas&#10;                        _uiState.postValue(LoginUiState.Error(message = R.string.err_bad_credentials))&#10;                    } else {&#10;                        // Otros errores&#10;                        _uiState.postValue(LoginUiState.Error(customMessage = errorMsg))&#10;                    }&#10;                }&#10;                else -&gt; {&#10;                    _uiState.postValue(LoginUiState.Error(message = R.string.err_bad_credentials))&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    companion object {&#10;        fun factory(repo: AuthRepository) = object : ViewModelProvider.Factory {&#10;            @Suppress(&quot;UNCHECKED_CAST&quot;)&#10;            override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T {&#10;                return LoginViewModel(repo) as T&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/src/OrderHistoryActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/src/OrderHistoryActivity.kt" />
              <option name="originalContent" value="package app.src&#10;&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import android.view.View&#10;import android.widget.Button&#10;import android.widget.ProgressBar&#10;import android.widget.TextView&#10;import android.widget.Toast&#10;import androidx.activity.viewModels&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import androidx.recyclerview.widget.RecyclerView&#10;import app.src.adapters.OrderHistoryAdapter&#10;import app.src.data.api.ApiClient&#10;import app.src.utils.NetworkUtils&#10;import app.src.utils.SessionManager&#10;&#10;class OrderHistoryActivity : BaseActivity() {&#10;&#10;    private val viewModel: CompraViewModel by viewModels()&#10;    private lateinit var recyclerView: RecyclerView&#10;    private lateinit var progressBar: ProgressBar&#10;    private lateinit var tvEmpty: TextView&#10;    private lateinit var tvError: TextView&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        setContentView(R.layout.activity_order_history)&#10;&#10;        // Load session token&#10;        val token = SessionManager.getToken(this)&#10;        if (token != null) {&#10;            ApiClient.setToken(token)&#10;        }&#10;&#10;        // Initialize views&#10;        recyclerView = findViewById(R.id.rv_order_history)&#10;        progressBar = findViewById(R.id.progress_bar)&#10;        tvEmpty = findViewById(R.id.tv_empty)&#10;        tvError = findViewById(R.id.tv_error)&#10;&#10;        recyclerView.layoutManager = LinearLayoutManager(this)&#10;&#10;        // Check if offline and show toast&#10;        val isOffline = !NetworkUtils.isNetworkAvailable(this)&#10;        if (isOffline) {&#10;            Toast.makeText(&#10;                this,&#10;                &quot; Modo Offline: Mostrando historial y códigos QR desde caché&quot;,&#10;                Toast.LENGTH_LONG&#10;            ).show()&#10;        }&#10;&#10;        // Observer&#10;        viewModel.historial.observe(this) { compras -&gt;&#10;            progressBar.visibility = View.GONE&#10;&#10;            if (compras.isEmpty()) {&#10;                recyclerView.visibility = View.GONE&#10;                tvEmpty.visibility = View.VISIBLE&#10;                tvError.visibility = View.GONE&#10;&#10;                // Si está offline y no hay datos, mostrar mensaje específico&#10;                if (isOffline) {&#10;                    tvEmpty.text = &quot;No hay historial en caché. Conéctate a internet para ver tus pedidos.&quot;&#10;                }&#10;            } else {&#10;                recyclerView.visibility = View.VISIBLE&#10;                tvEmpty.visibility = View.GONE&#10;                tvError.visibility = View.GONE&#10;&#10;                val adapter = OrderHistoryAdapter(compras) { compra -&gt;&#10;                    // Click on order - show details with QR&#10;                    val qrCode = compra.qr?.codigoQrHash&#10;                    if (qrCode != null) {&#10;                        val intent = Intent(this, OrderPickupActivity::class.java)&#10;                        intent.putExtra(&quot;qr_code&quot;, qrCode)&#10;                        intent.putExtra(&quot;compra_id&quot;, compra.id)&#10;                        intent.putExtra(&quot;total&quot;, compra.total)&#10;                        intent.putExtra(&quot;estado&quot;, compra.estado.name)&#10;                        startActivity(intent)&#10;                    } else {&#10;                        Toast.makeText(&#10;                            this,&#10;                            &quot;Este pedido no tiene código QR disponible&quot;,&#10;                            Toast.LENGTH_SHORT&#10;                        ).show()&#10;                    }&#10;                }&#10;                recyclerView.adapter = adapter&#10;            }&#10;        }&#10;&#10;        // Load history (con caché automático)&#10;        viewModel.cargarHistorial()&#10;&#10;        // Back button&#10;        findViewById&lt;Button&gt;(R.id.btn_back_to_home).setOnClickListener {&#10;            val intent = Intent(this, HomeActivity::class.java)&#10;            intent.flags = Intent.FLAG_ACTIVITY_CLEAR_TOP&#10;            startActivity(intent)&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package app.src&#10;&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import android.view.View&#10;import android.widget.Button&#10;import android.widget.ProgressBar&#10;import android.widget.TextView&#10;import android.widget.Toast&#10;import androidx.activity.viewModels&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import androidx.recyclerview.widget.RecyclerView&#10;import app.src.adapters.OrderHistoryAdapter&#10;import app.src.data.api.ApiClient&#10;import app.src.utils.NetworkUtils&#10;import app.src.utils.SessionManager&#10;&#10;class OrderHistoryActivity : BaseActivity() {&#10;&#10;    private val viewModel: CompraViewModel by viewModels()&#10;    private lateinit var recyclerView: RecyclerView&#10;    private lateinit var progressBar: ProgressBar&#10;    private lateinit var tvEmpty: TextView&#10;    private lateinit var tvError: TextView&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        setContentView(R.layout.activity_order_history)&#10;&#10;        // Load session token&#10;        val token = SessionManager.getToken(this)&#10;        if (token != null) {&#10;            ApiClient.setToken(token)&#10;        }&#10;&#10;        // Initialize views&#10;        recyclerView = findViewById(R.id.rv_order_history)&#10;        progressBar = findViewById(R.id.progress_bar)&#10;        tvEmpty = findViewById(R.id.tv_empty)&#10;        tvError = findViewById(R.id.tv_error)&#10;&#10;        recyclerView.layoutManager = LinearLayoutManager(this)&#10;&#10;        // Check if offline and show toast&#10;        val isOffline = !NetworkUtils.isNetworkAvailable(this)&#10;        if (isOffline) {&#10;            Toast.makeText(&#10;                this,&#10;                &quot; Modo Offline: Mostrando historial y códigos QR desde caché&quot;,&#10;                Toast.LENGTH_LONG&#10;            ).show()&#10;        }&#10;&#10;        // Observer&#10;        viewModel.historial.observe(this) { compras -&gt;&#10;            progressBar.visibility = View.GONE&#10;&#10;            if (compras.isEmpty()) {&#10;                recyclerView.visibility = View.GONE&#10;                tvEmpty.visibility = View.VISIBLE&#10;                tvError.visibility = View.GONE&#10;&#10;                // Si está offline y no hay datos, mostrar mensaje específico&#10;                if (isOffline) {&#10;                    tvEmpty.text = &quot;No hay historial en caché. Conéctate a internet para ver tus pedidos.&quot;&#10;                }&#10;            } else {&#10;                recyclerView.visibility = View.VISIBLE&#10;                tvEmpty.visibility = View.GONE&#10;                tvError.visibility = View.GONE&#10;&#10;                val adapter = OrderHistoryAdapter(compras) { compra -&gt;&#10;                    // ✅ Click on order - show details with QR (siempre disponible offline)&#10;                    val intent = Intent(this, OrderPickupActivity::class.java)&#10;                    intent.putExtra(&quot;qr_code&quot;, compra.qr?.codigoQrHash ?: &quot;&quot;)&#10;                    intent.putExtra(&quot;compra_id&quot;, compra.id)&#10;                    intent.putExtra(&quot;total&quot;, compra.total)&#10;                    intent.putExtra(&quot;estado&quot;, compra.estado.name)&#10;                    startActivity(intent)&#10;                }&#10;                recyclerView.adapter = adapter&#10;            }&#10;        }&#10;&#10;        // Load history (con caché automático)&#10;        viewModel.cargarHistorial()&#10;&#10;        // Back button&#10;        findViewById&lt;Button&gt;(R.id.btn_back_to_home).setOnClickListener {&#10;            val intent = Intent(this, HomeActivity::class.java)&#10;            intent.flags = Intent.FLAG_ACTIVITY_CLEAR_TOP&#10;            startActivity(intent)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/src/OrderPickupViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/src/OrderPickupViewModel.kt" />
              <option name="originalContent" value="package app.src&#10;&#10;import androidx.lifecycle.*&#10;import app.src.data.api.ApiClient&#10;import app.src.data.models.ActualizarEstadoRequest&#10;import app.src.data.models.Compra&#10;import app.src.data.models.EscanearQRRequest&#10;import app.src.data.models.EscanearQRResponse&#10;import app.src.data.models.EstadoCompra&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.launch&#10;&#10;sealed class OrderPickupState {&#10;    object Idle : OrderPickupState()&#10;    object Loading : OrderPickupState()&#10;    data class Success(val compra: Compra) : OrderPickupState()&#10;    data class QRScanned(val response: EscanearQRResponse) : OrderPickupState()&#10;    data class Error(val message: String) : OrderPickupState()&#10;}&#10;&#10;class OrderPickupViewModel : ViewModel() {&#10;&#10;    private val _state = MutableLiveData&lt;OrderPickupState&gt;(OrderPickupState.Idle)&#10;    val state: LiveData&lt;OrderPickupState&gt; = _state&#10;&#10;    private val _currentCompra = MutableLiveData&lt;Compra?&gt;()&#10;    val currentCompra: LiveData&lt;Compra?&gt; = _currentCompra&#10;&#10;    fun loadCompra(compra: Compra) {&#10;        _currentCompra.value = compra&#10;        _state.value = OrderPickupState.Success(compra)&#10;    }&#10;&#10;    fun actualizarEstado(compraId: Int, nuevoEstado: EstadoCompra) {&#10;        _state.value = OrderPickupState.Loading&#10;&#10;        viewModelScope.launch(Dispatchers.IO) {&#10;            try {&#10;                val estadoStr = when (nuevoEstado) {&#10;                    EstadoCompra.EN_PREPARACION -&gt; &quot;EN_PREPARACION&quot;&#10;                    EstadoCompra.LISTO -&gt; &quot;LISTO&quot;&#10;                    EstadoCompra.ENTREGADO -&gt; &quot;ENTREGADO&quot;&#10;                    else -&gt; nuevoEstado.name&#10;                }&#10;&#10;                val request = ActualizarEstadoRequest(estado = estadoStr)&#10;                val response = ApiClient.compraService.actualizarEstadoCompra(compraId, request)&#10;&#10;                if (response.isSuccessful &amp;&amp; response.body() != null) {&#10;                    val compraActualizada = response.body()!!&#10;                    _currentCompra.postValue(compraActualizada)&#10;                    _state.postValue(OrderPickupState.Success(compraActualizada))&#10;                } else {&#10;                    val errorMsg = response.errorBody()?.string() ?: &quot;Error al actualizar estado&quot;&#10;                    _state.postValue(OrderPickupState.Error(errorMsg))&#10;                }&#10;            } catch (e: Exception) {&#10;                _state.postValue(OrderPickupState.Error(e.message ?: &quot;Error de conexión&quot;))&#10;            }&#10;        }&#10;    }&#10;&#10;    fun escanearQR(codigoQrHash: String) {&#10;        _state.value = OrderPickupState.Loading&#10;&#10;        viewModelScope.launch(Dispatchers.IO) {&#10;            try {&#10;                val request = EscanearQRRequest(codigoQrHash = codigoQrHash)&#10;                val response = ApiClient.compraService.escanearQR(request)&#10;&#10;                if (response.isSuccessful &amp;&amp; response.body() != null) {&#10;                    val qrResponse = response.body()!!&#10;                    _state.postValue(OrderPickupState.QRScanned(qrResponse))&#10;                } else {&#10;                    val errorMsg = response.errorBody()?.string() ?: &quot;Error al escanear QR&quot;&#10;                    _state.postValue(OrderPickupState.Error(errorMsg))&#10;                }&#10;            } catch (e: Exception) {&#10;                _state.postValue(OrderPickupState.Error(e.message ?: &quot;Error de conexión&quot;))&#10;            }&#10;        }&#10;    }&#10;&#10;    fun canTransitionTo(currentEstado: EstadoCompra, targetEstado: EstadoCompra): Boolean {&#10;        return when (currentEstado) {&#10;            EstadoCompra.PAGADO -&gt; targetEstado == EstadoCompra.EN_PREPARACION&#10;            EstadoCompra.EN_PREPARACION -&gt; targetEstado == EstadoCompra.LISTO&#10;            EstadoCompra.LISTO -&gt; targetEstado == EstadoCompra.ENTREGADO&#10;            else -&gt; false&#10;        }&#10;    }&#10;&#10;    fun getNextEstado(currentEstado: EstadoCompra): EstadoCompra? {&#10;        return when (currentEstado) {&#10;            EstadoCompra.PAGADO -&gt; EstadoCompra.EN_PREPARACION&#10;            EstadoCompra.EN_PREPARACION -&gt; EstadoCompra.LISTO&#10;            EstadoCompra.LISTO -&gt; EstadoCompra.ENTREGADO&#10;            else -&gt; null&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package app.src&#13;&#10;&#13;&#10;import android.app.Application&#13;&#10;import androidx.lifecycle.*&#13;&#10;import app.src.data.models.Compra&#13;&#10;import app.src.data.models.EscanearQRResponse&#13;&#10;import app.src.data.models.EstadoCompra&#13;&#10;import app.src.data.repositories.CompraRepository&#13;&#10;import app.src.data.repositories.Result&#13;&#10;import kotlinx.coroutines.Dispatchers&#13;&#10;import kotlinx.coroutines.launch&#13;&#10;&#13;&#10;sealed class OrderPickupState {&#13;&#10;    object Idle : OrderPickupState()&#13;&#10;    object Loading : OrderPickupState()&#13;&#10;    data class Success(val compra: Compra) : OrderPickupState()&#13;&#10;    data class QRScanned(val response: EscanearQRResponse) : OrderPickupState()&#13;&#10;    data class Error(val message: String) : OrderPickupState()&#13;&#10;}&#13;&#10;&#13;&#10;class OrderPickupViewModel(application: Application) : AndroidViewModel(application) {&#13;&#10;&#13;&#10;    private val repository = CompraRepository()&#13;&#10;    &#13;&#10;    private val _state = MutableLiveData&lt;OrderPickupState&gt;(OrderPickupState.Idle)&#13;&#10;    val state: LiveData&lt;OrderPickupState&gt; = _state&#13;&#10;&#13;&#10;    private val _currentCompra = MutableLiveData&lt;Compra?&gt;()&#13;&#10;    val currentCompra: LiveData&lt;Compra?&gt; = _currentCompra&#13;&#10;&#13;&#10;    fun loadCompra(compra: Compra) {&#13;&#10;        _currentCompra.value = compra&#13;&#10;        _state.value = OrderPickupState.Success(compra)&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * ✅ Actualiza el estado de una orden (funciona OFFLINE)&#13;&#10;     */&#13;&#10;    fun actualizarEstado(compraId: Int, nuevoEstado: EstadoCompra) {&#13;&#10;        _state.value = OrderPickupState.Loading&#13;&#10;&#13;&#10;        viewModelScope.launch(Dispatchers.IO) {&#13;&#10;            try {&#13;&#10;                val estadoStr = when (nuevoEstado) {&#13;&#10;                    EstadoCompra.EN_PREPARACION -&gt; &quot;EN_PREPARACION&quot;&#13;&#10;                    EstadoCompra.LISTO -&gt; &quot;LISTO&quot;&#13;&#10;                    EstadoCompra.ENTREGADO -&gt; &quot;ENTREGADO&quot;&#13;&#10;                    else -&gt; nuevoEstado.name&#13;&#10;                }&#13;&#10;&#13;&#10;                // ✅ Usar CompraRepository que maneja offline automáticamente&#13;&#10;                val result = repository.actualizarEstado(getApplication(), compraId, estadoStr)&#13;&#10;&#13;&#10;                when (result) {&#13;&#10;                    is Result.Success -&gt; {&#13;&#10;                        val compraActualizada = result.data&#13;&#10;                        _currentCompra.postValue(compraActualizada)&#13;&#10;                        _state.postValue(OrderPickupState.Success(compraActualizada))&#13;&#10;                    }&#13;&#10;                    is Result.Error -&gt; {&#13;&#10;                        _state.postValue(OrderPickupState.Error(result.message))&#13;&#10;                    }&#13;&#10;                    else -&gt; {&#13;&#10;                        _state.postValue(OrderPickupState.Error(&quot;Error desconocido&quot;))&#13;&#10;                    }&#13;&#10;                }&#13;&#10;            } catch (e: Exception) {&#13;&#10;                _state.postValue(OrderPickupState.Error(e.message ?: &quot;Error de conexión&quot;))&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Escanea QR (requiere conexión)&#13;&#10;     */&#13;&#10;    fun escanearQR(codigoQrHash: String) {&#13;&#10;        _state.value = OrderPickupState.Loading&#13;&#10;&#13;&#10;        viewModelScope.launch(Dispatchers.IO) {&#13;&#10;            try {&#13;&#10;                val result = repository.escanearQR(codigoQrHash)&#13;&#10;&#13;&#10;                when (result) {&#13;&#10;                    is Result.Success -&gt; {&#13;&#10;                        val qrResponse = result.data&#13;&#10;                        _state.postValue(OrderPickupState.QRScanned(qrResponse))&#13;&#10;                    }&#13;&#10;                    is Result.Error -&gt; {&#13;&#10;                        _state.postValue(OrderPickupState.Error(result.message))&#13;&#10;                    }&#13;&#10;                    else -&gt; {&#13;&#10;                        _state.postValue(OrderPickupState.Error(&quot;Error desconocido&quot;))&#13;&#10;                    }&#13;&#10;                }&#13;&#10;            } catch (e: Exception) {&#13;&#10;                _state.postValue(OrderPickupState.Error(e.message ?: &quot;Error de conexión&quot;))&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun canTransitionTo(currentEstado: EstadoCompra, targetEstado: EstadoCompra): Boolean {&#13;&#10;        return when (currentEstado) {&#13;&#10;            EstadoCompra.PAGADO -&gt; targetEstado == EstadoCompra.EN_PREPARACION&#13;&#10;            EstadoCompra.EN_PREPARACION -&gt; targetEstado == EstadoCompra.LISTO&#13;&#10;            EstadoCompra.LISTO -&gt; targetEstado == EstadoCompra.ENTREGADO&#13;&#10;            else -&gt; false&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun getNextEstado(currentEstado: EstadoCompra): EstadoCompra? {&#13;&#10;        return when (currentEstado) {&#13;&#10;            EstadoCompra.PAGADO -&gt; EstadoCompra.EN_PREPARACION&#13;&#10;            EstadoCompra.EN_PREPARACION -&gt; EstadoCompra.LISTO&#13;&#10;            EstadoCompra.LISTO -&gt; EstadoCompra.ENTREGADO&#13;&#10;            else -&gt; null&#13;&#10;        }&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/src/OrderSummaryActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/src/OrderSummaryActivity.kt" />
              <option name="originalContent" value="package app.src&#10;&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import android.util.Log&#10;import android.view.View&#10;import android.widget.Button&#10;import android.widget.ProgressBar&#10;import android.widget.TextView&#10;import android.widget.Toast&#10;import androidx.activity.viewModels&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import androidx.recyclerview.widget.RecyclerView&#10;import app.src.adapters.CartAdapter&#10;import app.src.data.api.ApiClient&#10;import app.src.data.models.DetalleCompraRequest&#10;import app.src.data.repositories.Result&#10;import app.src.data.repositories.UsuarioRepository&#10;import app.src.utils.AnalyticsLogger&#10;import app.src.utils.CartManager&#10;import app.src.utils.NetworkUtils&#10;import app.src.utils.SessionManager&#10;import androidx.lifecycle.lifecycleScope&#10;import kotlinx.coroutines.launch&#10;import java.util.Locale&#10;&#10;class OrderSummaryActivity : BaseActivity() {&#10;&#10;    private val viewModel: CompraViewModel by viewModels()&#10;    private val usuarioRepo = UsuarioRepository()&#10;    private lateinit var adapter: CartAdapter&#10;    private lateinit var recyclerView: RecyclerView&#10;    private lateinit var progressBar: ProgressBar&#10;    private lateinit var tvEmptyCart: TextView&#10;    private lateinit var tvSubtotal: TextView&#10;    private lateinit var tvTotal: TextView&#10;    private lateinit var btnCheckout: Button&#10;    private lateinit var btnBackToHome: Button&#10;&#10;    private var payTapStartTime: Long = 0&#10;&#10;    companion object {&#10;        private const val TAG = &quot;OrderSummaryActivity&quot;&#10;    }&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        setContentView(R.layout.activity_order_summary)&#10;&#10;        // Load session token&#10;        val token = SessionManager.getToken(this)&#10;        if (token != null) {&#10;            ApiClient.setToken(token)&#10;        }&#10;&#10;        // Initialize views&#10;        recyclerView = findViewById(R.id.rv_cart_items)&#10;        progressBar = findViewById(R.id.progress_bar)&#10;        tvEmptyCart = findViewById(R.id.tv_empty_cart)&#10;        tvSubtotal = findViewById(R.id.tv_subtotal_value)&#10;        tvTotal = findViewById(R.id.tv_total_value)&#10;        btnCheckout = findViewById(R.id.btn_checkout)&#10;        btnBackToHome = findViewById(R.id.btn_back_to_home)&#10;&#10;        // Setup RecyclerView&#10;        recyclerView.layoutManager = LinearLayoutManager(this)&#10;        adapter = CartAdapter(CartManager.getItems()) { productoId -&gt;&#10;            CartManager.removeProduct(productoId)&#10;            updateCartDisplay()&#10;        }&#10;        recyclerView.adapter = adapter&#10;&#10;        // Update initial display&#10;        updateCartDisplay()&#10;&#10;        // ViewModel Observer&#10;        viewModel.uiState.observe(this) { state -&gt;&#10;            when (state) {&#10;                is CompraUiState.Loading -&gt; {&#10;                    progressBar.visibility = View.VISIBLE&#10;                    btnCheckout.isEnabled = false&#10;                    Log.d(TAG, &quot;⏳ Procesando pago...&quot;)&#10;                }&#10;                is CompraUiState.Success -&gt; {&#10;                    progressBar.visibility = View.GONE&#10;                    btnCheckout.isEnabled = true&#10;&#10;                    // Emitir evento de pago completado exitosamente&#10;                    Log.d(TAG, &quot;✅ Pago exitoso - Emitiendo evento payment_completed&quot;)&#10;                    emitPaymentCompletedEvent(success = true, paymentMethod = &quot;wallet&quot;)&#10;&#10;                    // Clear cart&#10;                    CartManager.clear()&#10;&#10;                    // Update user balance from API&#10;                    updateUserBalance {&#10;                        // Navigate to OrderPickupActivity with QR code&#10;                        val compra = state.compra&#10;                        val qrCode = compra.qr?.codigoQrHash&#10;&#10;                        if (qrCode != null) {&#10;                            val intent = Intent(this, OrderPickupActivity::class.java)&#10;                            intent.putExtra(&quot;qr_code&quot;, qrCode)&#10;                            intent.putExtra(&quot;compra_id&quot;, compra.id)&#10;                            intent.putExtra(&quot;total&quot;, compra.total)&#10;                            intent.putExtra(&quot;estado&quot;, compra.estado.name)&#10;                            startActivity(intent)&#10;                            finish()&#10;                        } else {&#10;                            Toast.makeText(this, &quot;Order created successfully but no QR code was generated&quot;, Toast.LENGTH_LONG).show()&#10;                            finish()&#10;                        }&#10;                    }&#10;                }&#10;                is CompraUiState.Error -&gt; {&#10;                    progressBar.visibility = View.GONE&#10;                    btnCheckout.isEnabled = true&#10;&#10;                    // Emitir evento de pago fallido&#10;                    Log.d(TAG, &quot;❌ Pago fallido - Emitiendo evento payment_completed (success=false)&quot;)&#10;                    emitPaymentCompletedEvent(success = false, paymentMethod = &quot;wallet&quot;)&#10;&#10;                    val errorMessage = when {&#10;                        state.message.contains(&quot;Saldo insuficiente&quot;, ignoreCase = true) -&gt;&#10;                            &quot;Insufficient balance. Please recharge your account.&quot;&#10;                        state.message.contains(&quot;disponible&quot;, ignoreCase = true) -&gt;&#10;                            &quot;One or more products are not available.&quot;&#10;                        else -&gt; &quot;Error: ${state.message}&quot;&#10;                    }&#10;&#10;                    Toast.makeText(this, errorMessage, Toast.LENGTH_LONG).show()&#10;                }&#10;                else -&gt; {&#10;                    progressBar.visibility = View.GONE&#10;                    btnCheckout.isEnabled = true&#10;                }&#10;            }&#10;        }&#10;&#10;        btnCheckout.setOnClickListener {&#10;            if (CartManager.isEmpty()) {&#10;                Toast.makeText(this, &quot;Cart is empty&quot;, Toast.LENGTH_SHORT).show()&#10;                return@setOnClickListener&#10;            }&#10;&#10;            // ✅ PERMITIR CHECKOUT OFFLINE - El CompraRepository maneja el modo offline&#10;            // Crear lista de productos para la compra&#10;            val productos = CartManager.getItems().map { item -&gt;&#10;                DetalleCompraRequest(&#10;                    idProducto = item.producto.id,&#10;                    cantidad = item.cantidad&#10;                )&#10;            }&#10;&#10;            // Crear compra (funciona online y offline gracias a CompraRepository)&#10;            viewModel.crearCompra(productos)&#10;        }&#10;&#10;        btnBackToHome.setOnClickListener {&#10;            val intent = Intent(this, HomeActivity::class.java)&#10;            intent.flags = Intent.FLAG_ACTIVITY_CLEAR_TOP&#10;            startActivity(intent)&#10;        }&#10;    }&#10;&#10;    private fun updateCartDisplay() {&#10;        val items = CartManager.getItems()&#10;&#10;        if (items.isEmpty()) {&#10;            recyclerView.visibility = View.GONE&#10;            tvEmptyCart.visibility = View.VISIBLE&#10;            btnCheckout.isEnabled = false&#10;        } else {&#10;            recyclerView.visibility = View.VISIBLE&#10;            tvEmptyCart.visibility = View.GONE&#10;            btnCheckout.isEnabled = true&#10;            adapter.updateItems(items)&#10;        }&#10;&#10;        val total = CartManager.getTotal()&#10;        tvSubtotal.text = String.format(Locale.US, &quot;$%.2f&quot;, total)&#10;        tvTotal.text = String.format(Locale.US, &quot;$%.2f&quot;, total)&#10;    }&#10;&#10;    private fun updateUserBalance(onComplete: () -&gt; Unit) {&#10;        lifecycleScope.launch {&#10;            when (val result = usuarioRepo.obtenerPerfil()) {&#10;                is Result.Success -&gt; {&#10;                    val usuario = result.data&#10;                    // Update session with new balance&#10;                    SessionManager.saveUserData(&#10;                        this@OrderSummaryActivity,&#10;                        usuario.id,&#10;                        usuario.nombre,&#10;                        usuario.email,&#10;                        usuario.saldo&#10;                    )&#10;                    onComplete()&#10;                }&#10;                is Result.Error -&gt; {&#10;                    // If we can't get the updated balance, still proceed&#10;                    Toast.makeText(&#10;                        this@OrderSummaryActivity,&#10;                        &quot;Warning: Could not update balance&quot;,&#10;                        Toast.LENGTH_SHORT&#10;                    ).show()&#10;                    onComplete()&#10;                }&#10;                else -&gt; {&#10;                    onComplete()&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun emitPaymentCompletedEvent(success: Boolean, paymentMethod: String?) {&#10;        val duration = System.currentTimeMillis() - payTapStartTime&#10;        Log.d(TAG, &quot; Emitiendo payment_completed - Duration: ${duration}ms, Success: $success&quot;)&#10;        AnalyticsLogger.logPaymentCompleted(&#10;            context = this,&#10;            durationMs = duration,&#10;            success = success,&#10;            paymentMethod = paymentMethod&#10;        )&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package app.src&#10;&#10;import android.content.Intent&#10;import android.os.Bundle&#10;import android.util.Log&#10;import android.view.View&#10;import android.widget.Button&#10;import android.widget.ProgressBar&#10;import android.widget.TextView&#10;import android.widget.Toast&#10;import androidx.activity.viewModels&#10;import androidx.recyclerview.widget.LinearLayoutManager&#10;import androidx.recyclerview.widget.RecyclerView&#10;import app.src.adapters.CartAdapter&#10;import app.src.data.api.ApiClient&#10;import app.src.data.models.DetalleCompraRequest&#10;import app.src.data.repositories.Result&#10;import app.src.data.repositories.UsuarioRepository&#10;import app.src.utils.AnalyticsLogger&#10;import app.src.utils.CartManager&#10;import app.src.utils.NetworkUtils&#10;import app.src.utils.SessionManager&#10;import androidx.lifecycle.lifecycleScope&#10;import kotlinx.coroutines.launch&#10;import java.util.Locale&#10;&#10;class OrderSummaryActivity : BaseActivity() {&#10;&#10;    private val viewModel: CompraViewModel by viewModels()&#10;    private val usuarioRepo = UsuarioRepository()&#10;    private lateinit var adapter: CartAdapter&#10;    private lateinit var recyclerView: RecyclerView&#10;    private lateinit var progressBar: ProgressBar&#10;    private lateinit var tvEmptyCart: TextView&#10;    private lateinit var tvSubtotal: TextView&#10;    private lateinit var tvTotal: TextView&#10;    private lateinit var btnCheckout: Button&#10;    private lateinit var btnBackToHome: Button&#10;&#10;    private var payTapStartTime: Long = 0&#10;&#10;    companion object {&#10;        private const val TAG = &quot;OrderSummaryActivity&quot;&#10;    }&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        setContentView(R.layout.activity_order_summary)&#10;&#10;        // Load session token&#10;        val token = SessionManager.getToken(this)&#10;        if (token != null) {&#10;            ApiClient.setToken(token)&#10;        }&#10;&#10;        // Initialize views&#10;        recyclerView = findViewById(R.id.rv_cart_items)&#10;        progressBar = findViewById(R.id.progress_bar)&#10;        tvEmptyCart = findViewById(R.id.tv_empty_cart)&#10;        tvSubtotal = findViewById(R.id.tv_subtotal_value)&#10;        tvTotal = findViewById(R.id.tv_total_value)&#10;        btnCheckout = findViewById(R.id.btn_checkout)&#10;        btnBackToHome = findViewById(R.id.btn_back_to_home)&#10;&#10;        // Setup RecyclerView&#10;        recyclerView.layoutManager = LinearLayoutManager(this)&#10;        adapter = CartAdapter(CartManager.getItems()) { productoId -&gt;&#10;            CartManager.removeProduct(productoId)&#10;            updateCartDisplay()&#10;        }&#10;        recyclerView.adapter = adapter&#10;&#10;        // Update initial display&#10;        updateCartDisplay()&#10;&#10;        // ViewModel Observer&#10;        viewModel.uiState.observe(this) { state -&gt;&#10;            when (state) {&#10;                is CompraUiState.Loading -&gt; {&#10;                    progressBar.visibility = View.VISIBLE&#10;                    btnCheckout.isEnabled = false&#10;                    Log.d(TAG, &quot;⏳ Procesando pago...&quot;)&#10;                }&#10;                is CompraUiState.Success -&gt; {&#10;                    progressBar.visibility = View.GONE&#10;                    btnCheckout.isEnabled = true&#10;&#10;                    // Emitir evento de pago completado exitosamente&#10;                    Log.d(TAG, &quot;✅ Pago exitoso - Emitiendo evento payment_completed&quot;)&#10;                    emitPaymentCompletedEvent(success = true, paymentMethod = &quot;wallet&quot;)&#10;&#10;                    // Clear cart&#10;                    CartManager.clear()&#10;&#10;                    // Update user balance from API&#10;                    updateUserBalance {&#10;                        // Navigate to OrderPickupActivity with QR code&#10;                        val compra = state.compra&#10;                        val qrCode = compra.qr?.codigoQrHash&#10;&#10;                        if (qrCode != null) {&#10;                            val intent = Intent(this, OrderPickupActivity::class.java)&#10;                            intent.putExtra(&quot;qr_code&quot;, qrCode)&#10;                            intent.putExtra(&quot;compra_id&quot;, compra.id)&#10;                            intent.putExtra(&quot;total&quot;, compra.total)&#10;                            intent.putExtra(&quot;estado&quot;, compra.estado.name)&#10;                            startActivity(intent)&#10;                            finish()&#10;                        } else {&#10;                            Toast.makeText(this, &quot;Order created successfully but no QR code was generated&quot;, Toast.LENGTH_LONG).show()&#10;                            finish()&#10;                        }&#10;                    }&#10;                }&#10;                is CompraUiState.Error -&gt; {&#10;                    progressBar.visibility = View.GONE&#10;                    btnCheckout.isEnabled = true&#10;&#10;                    // ✅ DETECTAR SI ES ORDEN GUARDADA EN OUTBOX (MODO OFFLINE)&#10;                    val isOfflineOrder = state.message.contains(&quot;se guardó&quot;, ignoreCase = true) ||&#10;                            state.message.contains(&quot;procesará cuando&quot;, ignoreCase = true)&#10;&#10;                    if (isOfflineOrder) {&#10;                        // Orden guardada exitosamente en modo offline&#10;                        Log.d(TAG, &quot; Orden guardada en outbox - modo offline&quot;)&#10;                        emitPaymentCompletedEvent(success = true, paymentMethod = &quot;wallet_offline&quot;)&#10;&#10;                        // Limpiar carrito&#10;                        CartManager.clear()&#10;&#10;                        // Mostrar mensaje positivo&#10;                        Toast.makeText(&#10;                            this,&#10;                            &quot;✅ Tu pedido se guardó correctamente. Se procesará cuando haya conexión.&quot;,&#10;                            Toast.LENGTH_LONG&#10;                        ).show()&#10;&#10;                        // Volver al Home&#10;                        val intent = Intent(this, HomeActivity::class.java)&#10;                        intent.flags = Intent.FLAG_ACTIVITY_CLEAR_TOP&#10;                        startActivity(intent)&#10;                        finish()&#10;                    } else {&#10;                        // Error real de pago&#10;                        Log.d(TAG, &quot;❌ Pago fallido - Emitiendo evento payment_completed (success=false)&quot;)&#10;                        emitPaymentCompletedEvent(success = false, paymentMethod = &quot;wallet&quot;)&#10;&#10;                        val errorMessage = when {&#10;                            state.message.contains(&quot;Saldo insuficiente&quot;, ignoreCase = true) -&gt;&#10;                                &quot;Insufficient balance. Please recharge your account.&quot;&#10;                            state.message.contains(&quot;disponible&quot;, ignoreCase = true) -&gt;&#10;                                &quot;One or more products are not available.&quot;&#10;                            else -&gt; &quot;Error: ${state.message}&quot;&#10;                        }&#10;&#10;                        Toast.makeText(this, errorMessage, Toast.LENGTH_LONG).show()&#10;                    }&#10;                }&#10;                else -&gt; {&#10;                    progressBar.visibility = View.GONE&#10;                    btnCheckout.isEnabled = true&#10;                }&#10;            }&#10;        }&#10;&#10;        btnCheckout.setOnClickListener {&#10;            if (CartManager.isEmpty()) {&#10;                Toast.makeText(this, &quot;Cart is empty&quot;, Toast.LENGTH_SHORT).show()&#10;                return@setOnClickListener&#10;            }&#10;&#10;            // ✅ PERMITIR CHECKOUT OFFLINE - El CompraRepository maneja el modo offline&#10;            // Crear lista de productos para la compra&#10;            val productos = CartManager.getItems().map { item -&gt;&#10;                DetalleCompraRequest(&#10;                    idProducto = item.producto.id,&#10;                    cantidad = item.cantidad&#10;                )&#10;            }&#10;&#10;            // Crear compra (funciona online y offline gracias a CompraRepository)&#10;            viewModel.crearCompra(productos)&#10;        }&#10;&#10;        btnBackToHome.setOnClickListener {&#10;            val intent = Intent(this, HomeActivity::class.java)&#10;            intent.flags = Intent.FLAG_ACTIVITY_CLEAR_TOP&#10;            startActivity(intent)&#10;        }&#10;    }&#10;&#10;    private fun updateCartDisplay() {&#10;        val items = CartManager.getItems()&#10;&#10;        if (items.isEmpty()) {&#10;            recyclerView.visibility = View.GONE&#10;            tvEmptyCart.visibility = View.VISIBLE&#10;            btnCheckout.isEnabled = false&#10;        } else {&#10;            recyclerView.visibility = View.VISIBLE&#10;            tvEmptyCart.visibility = View.GONE&#10;            btnCheckout.isEnabled = true&#10;            adapter.updateItems(items)&#10;        }&#10;&#10;        // ✅ USAR Dispatchers.Default para cálculos pesados del total&#10;        lifecycleScope.launch {&#10;            val (subtotal, total) = kotlinx.coroutines.withContext(kotlinx.coroutines.Dispatchers.Default) {&#10;                // Cálculos complejos en background thread (importante para listas grandes)&#10;                val calculatedSubtotal = items.sumOf { it.subtotal }&#10;                val calculatedTotal = calculatedSubtotal // Aquí podrías agregar impuestos, descuentos, etc.&#10;                Pair(calculatedSubtotal, calculatedTotal)&#10;            }&#10;            &#10;            // Actualizar UI en Main thread&#10;            tvSubtotal.text = String.format(Locale.US, &quot;$%.2f&quot;, subtotal)&#10;            tvTotal.text = String.format(Locale.US, &quot;$%.2f&quot;, total)&#10;        }&#10;    }&#10;&#10;    private fun updateUserBalance(onComplete: () -&gt; Unit) {&#10;        lifecycleScope.launch {&#10;            when (val result = usuarioRepo.obtenerPerfil()) {&#10;                is Result.Success -&gt; {&#10;                    val usuario = result.data&#10;                    // Update session with new balance&#10;                    SessionManager.saveUserData(&#10;                        this@OrderSummaryActivity,&#10;                        usuario.id,&#10;                        usuario.nombre,&#10;                        usuario.email,&#10;                        usuario.saldo&#10;                    )&#10;                    onComplete()&#10;                }&#10;                is Result.Error -&gt; {&#10;                    // If we can't get the updated balance, still proceed&#10;                    Toast.makeText(&#10;                        this@OrderSummaryActivity,&#10;                        &quot;Warning: Could not update balance&quot;,&#10;                        Toast.LENGTH_SHORT&#10;                    ).show()&#10;                    onComplete()&#10;                }&#10;                else -&gt; {&#10;                    onComplete()&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun emitPaymentCompletedEvent(success: Boolean, paymentMethod: String?) {&#10;        val duration = System.currentTimeMillis() - payTapStartTime&#10;        Log.d(TAG, &quot; Emitiendo payment_completed - Duration: ${duration}ms, Success: $success&quot;)&#10;        AnalyticsLogger.logPaymentCompleted(&#10;            context = this,&#10;            durationMs = duration,&#10;            success = success,&#10;            paymentMethod = paymentMethod&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/src/data/local/AppDatabase.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/src/data/local/AppDatabase.kt" />
              <option name="originalContent" value="package app.src.data.local&#10;&#10;import android.content.Context&#10;import androidx.room.Database&#10;import androidx.room.Room&#10;import androidx.room.RoomDatabase&#10;import app.src.data.local.dao.CatalogDao&#10;import app.src.data.local.dao.OrderDao&#10;import app.src.data.local.dao.OrderOutboxDao&#10;import app.src.data.local.entities.CatalogPageEntity&#10;import app.src.data.local.entities.OrderEntity&#10;import app.src.data.local.entities.OrderItemEntity&#10;import app.src.data.local.entities.OrderOutboxEntity&#10;&#10;/**&#10; * Base de datos Room principal&#10; * Contiene 3 capas de almacenamiento:&#10; * 1. Orders + OrderItems (historial y estado de órdenes)&#10; * 2. OrderOutbox (cola de sincronización offline)&#10; * 3. CatalogPages (cache de productos y categorías con TTL)&#10; */&#10;@Database(&#10;    entities = [&#10;        OrderEntity::class,&#10;        OrderItemEntity::class,&#10;        OrderOutboxEntity::class,&#10;        CatalogPageEntity::class&#10;    ],&#10;    version = 1,&#10;    exportSchema = false&#10;)&#10;abstract class AppDatabase : RoomDatabase() {&#10;&#10;    abstract fun orderDao(): OrderDao&#10;    abstract fun orderOutboxDao(): OrderOutboxDao&#10;    abstract fun catalogDao(): CatalogDao&#10;&#10;    companion object {&#10;        @Volatile&#10;        private var INSTANCE: AppDatabase? = null&#10;&#10;        fun getDatabase(context: Context): AppDatabase {&#10;            return INSTANCE ?: synchronized(this) {&#10;                val instance = Room.databaseBuilder(&#10;                    context.applicationContext,&#10;                    AppDatabase::class.java,&#10;                    &quot;tapandtoast_db&quot;&#10;                )&#10;                    .fallbackToDestructiveMigration()&#10;                    .build()&#10;                INSTANCE = instance&#10;                instance&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package app.src.data.local&#13;&#10;&#13;&#10;import android.content.Context&#13;&#10;import androidx.room.Database&#13;&#10;import androidx.room.Room&#13;&#10;import androidx.room.RoomDatabase&#13;&#10;import app.src.data.local.dao.CatalogDao&#13;&#10;import app.src.data.local.dao.OrderDao&#13;&#10;import app.src.data.local.dao.OrderOutboxDao&#13;&#10;import app.src.data.local.entities.CatalogPageEntity&#13;&#10;import app.src.data.local.entities.OrderEntity&#13;&#10;import app.src.data.local.entities.OrderItemEntity&#13;&#10;import app.src.data.local.entities.OrderOutboxEntity&#13;&#10;&#13;&#10;/**&#13;&#10; * Base de datos Room principal&#13;&#10; * Contiene 3 capas de almacenamiento:&#13;&#10; * 1. Orders + OrderItems (historial y estado de órdenes)&#13;&#10; * 2. OrderOutbox (cola de sincronización offline)&#13;&#10; * 3. CatalogPages (cache de productos y categorías con TTL)&#13;&#10; */&#13;&#10;@Database(&#13;&#10;    entities = [&#13;&#10;        OrderEntity::class,&#13;&#10;        OrderItemEntity::class,&#13;&#10;        OrderOutboxEntity::class,&#13;&#10;        CatalogPageEntity::class&#13;&#10;    ],&#13;&#10;    version = 2, // ✅ INCREMENTADO de 1 a 2 por el campo qrCode agregado a OrderEntity&#13;&#10;    exportSchema = false&#13;&#10;)&#13;&#10;abstract class AppDatabase : RoomDatabase() {&#13;&#10;&#13;&#10;    abstract fun orderDao(): OrderDao&#13;&#10;    abstract fun orderOutboxDao(): OrderOutboxDao&#13;&#10;    abstract fun catalogDao(): CatalogDao&#13;&#10;&#13;&#10;    companion object {&#13;&#10;        @Volatile&#13;&#10;        private var INSTANCE: AppDatabase? = null&#13;&#10;&#13;&#10;        fun getDatabase(context: Context): AppDatabase {&#13;&#10;            return INSTANCE ?: synchronized(this) {&#13;&#10;                val instance = Room.databaseBuilder(&#13;&#10;                    context.applicationContext,&#13;&#10;                    AppDatabase::class.java,&#13;&#10;                    &quot;tapandtoast_db&quot;&#13;&#10;                )&#13;&#10;                    .fallbackToDestructiveMigration()&#13;&#10;                    .build()&#13;&#10;                INSTANCE = instance&#13;&#10;                instance&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/src/data/local/dao/OrderDao.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/src/data/local/dao/OrderDao.kt" />
              <option name="originalContent" value="package app.src.data.local.dao&#10;&#10;import androidx.room.*&#10;import app.src.data.local.entities.OrderEntity&#10;import app.src.data.local.entities.OrderItemEntity&#10;import kotlinx.coroutines.flow.Flow&#10;&#10;@Dao&#10;interface OrderDao {&#10;&#10;    // === INSERCIÓN ===&#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#10;    suspend fun insertOrder(order: OrderEntity): Long&#10;&#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#10;    suspend fun insertOrderItems(items: List&lt;OrderItemEntity&gt;)&#10;&#10;    @Transaction&#10;    suspend fun insertOrderWithItems(order: OrderEntity, items: List&lt;OrderItemEntity&gt;) {&#10;        insertOrder(order)&#10;        insertOrderItems(items)&#10;    }&#10;&#10;    // === CONSULTAS ===&#10;    @Query(&quot;SELECT * FROM orders WHERE userId = :userId ORDER BY createdAt DESC&quot;)&#10;    fun getOrdersByUser(userId: Int): Flow&lt;List&lt;OrderEntity&gt;&gt;&#10;&#10;    @Query(&quot;SELECT * FROM orders WHERE id = :orderId&quot;)&#10;    suspend fun getOrderById(orderId: Int): OrderEntity?&#10;&#10;    @Query(&quot;SELECT * FROM order_items WHERE orderId = :orderId&quot;)&#10;    suspend fun getOrderItems(orderId: Int): List&lt;OrderItemEntity&gt;&#10;&#10;    @Query(&quot;SELECT * FROM orders WHERE status = :status AND userId = :userId ORDER BY createdAt DESC LIMIT 1&quot;)&#10;    suspend fun getLastOrderByStatus(userId: Int, status: String): OrderEntity?&#10;&#10;    // === ACTUALIZACIÓN ===&#10;    @Query(&quot;UPDATE orders SET status = :status, readyAt = :readyAt WHERE id = :orderId&quot;)&#10;    suspend fun updateOrderStatus(orderId: Int, status: String, readyAt: Long? = null)&#10;&#10;    @Query(&quot;UPDATE orders SET status = 'DELIVERED', deliveredAt = :deliveredAt WHERE id = :orderId&quot;)&#10;    suspend fun markAsDelivered(orderId: Int, deliveredAt: Long)&#10;&#10;    // === ELIMINACIÓN ===&#10;    @Query(&quot;DELETE FROM orders WHERE createdAt &lt; :timestamp&quot;)&#10;    suspend fun deleteOldOrders(timestamp: Long)&#10;&#10;    @Query(&quot;DELETE FROM orders&quot;)&#10;    suspend fun clearAll()&#10;&#10;    // === ESTADÍSTICAS ===&#10;    @Query(&quot;SELECT COUNT(*) FROM orders WHERE userId = :userId&quot;)&#10;    suspend fun getOrderCount(userId: Int): Int&#10;&#10;    @Query(&quot;SELECT * FROM orders WHERE status = 'READY' AND userId = :userId LIMIT 1&quot;)&#10;    suspend fun getActiveReadyOrder(userId: Int): OrderEntity?&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package app.src.data.local.dao&#10;&#10;import androidx.room.*&#10;import app.src.data.local.entities.OrderEntity&#10;import app.src.data.local.entities.OrderItemEntity&#10;import kotlinx.coroutines.flow.Flow&#10;&#10;@Dao&#10;interface OrderDao {&#10;&#10;    // === INSERCIÓN ===&#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#10;    suspend fun insertOrder(order: OrderEntity): Long&#10;&#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#10;    suspend fun insertOrderItems(items: List&lt;OrderItemEntity&gt;)&#10;&#10;    @Transaction&#10;    suspend fun insertOrderWithItems(order: OrderEntity, items: List&lt;OrderItemEntity&gt;) {&#10;        insertOrder(order)&#10;        insertOrderItems(items)&#10;    }&#10;&#10;    // === CONSULTAS ===&#10;    @Query(&quot;SELECT * FROM orders WHERE userId = :userId ORDER BY createdAt DESC&quot;)&#10;    fun getOrdersByUser(userId: Int): Flow&lt;List&lt;OrderEntity&gt;&gt;&#10;&#10;    @Query(&quot;SELECT * FROM orders WHERE id = :orderId&quot;)&#10;    suspend fun getOrderById(orderId: Int): OrderEntity?&#10;&#10;    @Query(&quot;SELECT * FROM order_items WHERE orderId = :orderId&quot;)&#10;    suspend fun getOrderItems(orderId: Int): List&lt;OrderItemEntity&gt;&#10;&#10;    @Query(&quot;SELECT * FROM orders WHERE status = :status AND userId = :userId ORDER BY createdAt DESC LIMIT 1&quot;)&#10;    suspend fun getLastOrderByStatus(userId: Int, status: String): OrderEntity?&#10;&#10;    // === ACTUALIZACIÓN ===&#10;    @Query(&quot;UPDATE orders SET status = :status, readyAt = :readyAt WHERE id = :orderId&quot;)&#10;    suspend fun updateOrderStatus(orderId: Int, status: String, readyAt: Long? = null)&#10;&#10;    @Query(&quot;UPDATE orders SET status = 'DELIVERED', deliveredAt = :deliveredAt WHERE id = :orderId&quot;)&#10;    suspend fun markAsDelivered(orderId: Int, deliveredAt: Long)&#10;&#10;    // === ELIMINACIÓN ===&#10;    @Query(&quot;DELETE FROM orders WHERE createdAt &lt; :timestamp&quot;)&#10;    suspend fun deleteOldOrders(timestamp: Long)&#10;&#10;    @Query(&quot;DELETE FROM orders&quot;)&#10;    suspend fun clearAll()&#10;&#10;    // === ESTADÍSTICAS ===&#10;    @Query(&quot;SELECT COUNT(*) FROM orders WHERE userId = :userId&quot;)&#10;    suspend fun getOrderCount(userId: Int): Int&#10;&#10;    @Query(&quot;SELECT * FROM orders WHERE status = 'READY' AND userId = :userId LIMIT 1&quot;)&#10;    suspend fun getActiveReadyOrder(userId: Int): OrderEntity?&#10;&#10;    // === OBTENER ÚLTIMO ID PARA ÓRDENES OFFLINE ===&#10;    @Query(&quot;SELECT MAX(id) FROM orders WHERE id &gt; 0&quot;)&#10;    suspend fun getMaxOrderId(): Int?&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/src/data/local/entities/OrderEntity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/src/data/local/entities/OrderEntity.kt" />
              <option name="originalContent" value="package app.src.data.local.entities&#10;&#10;import androidx.room.Entity&#10;import androidx.room.PrimaryKey&#10;&#10;/**&#10; * Entidad Room para órdenes confirmadas&#10; * Almacena resumen de órdenes para acceso offline&#10; */&#10;@Entity(tableName = &quot;orders&quot;)&#10;data class OrderEntity(&#10;    @PrimaryKey&#10;    val id: Int,&#10;    val status: String, // PENDING, READY, DELIVERED&#10;    val total: Double,&#10;    val createdAt: Long,&#10;    val readyAt: Long? = null,&#10;    val deliveredAt: Long? = null,&#10;    val userId: Int&#10;)&#10;" />
              <option name="updatedContent" value="package app.src.data.local.entities&#10;&#10;import androidx.room.Entity&#10;import androidx.room.PrimaryKey&#10;&#10;/**&#10; * Entidad Room para órdenes confirmadas&#10; * Almacena resumen de órdenes para acceso offline&#10; */&#10;@Entity(tableName = &quot;orders&quot;)&#10;data class OrderEntity(&#10;    @PrimaryKey&#10;    val id: Int,&#10;    val status: String, // PENDING, READY, DELIVERED&#10;    val total: Double,&#10;    val createdAt: Long,&#10;    val readyAt: Long? = null,&#10;    val deliveredAt: Long? = null,&#10;    val userId: Int,&#10;    val qrCode: String? = null // ✅ NUEVO: Almacenar QR para acceso offline&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/src/data/repositories/CompraRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/src/data/repositories/CompraRepository.kt" />
              <option name="originalContent" value="package app.src.data.repositories&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import app.src.data.api.ApiClient&#10;import app.src.data.models.Compra&#10;import app.src.data.models.CompraRequest&#10;import app.src.data.models.ActualizarEstadoRequest&#10;import app.src.data.models.EscanearQRRequest&#10;import app.src.data.models.EscanearQRResponse&#10;import app.src.data.models.EstadoCompra&#10;import app.src.data.models.DetalleCompraResponse&#10;import app.src.data.models.Producto&#10;import app.src.data.models.TipoProducto&#10;import app.src.utils.NetworkUtils&#10;import app.src.data.local.AppDatabase&#10;import app.src.data.local.DataStoreManager&#10;import app.src.data.local.entities.OrderEntity&#10;import app.src.data.local.entities.OrderItemEntity&#10;import app.src.data.local.entities.OrderOutboxEntity&#10;import com.google.gson.Gson&#10;import kotlinx.coroutines.flow.first&#10;&#10;class CompraRepository {&#10;&#10;    private val api = ApiClient.compraService&#10;    private val TAG = &quot;CompraRepository&quot;&#10;    private val gson = Gson()&#10;&#10;    /**&#10;     * Obtiene el historial de compras del usuario&#10;     * Estrategia Cache-First: Lee de Room primero, actualiza desde API en background&#10;     */&#10;    suspend fun obtenerHistorial(context: Context): Result&lt;List&lt;Compra&gt;&gt; {&#10;        return try {&#10;            val database = AppDatabase.getDatabase(context)&#10;            val dataStore = DataStoreManager(context)&#10;            val userId = dataStore.userId.first() ?: 0&#10;&#10;            // 1. Leer desde Room primero (instantáneo)&#10;            val cachedOrders = database.orderDao().getOrdersByUser(userId).first()&#10;&#10;            if (cachedOrders.isNotEmpty()) {&#10;                Log.d(TAG, &quot; Cargando ${cachedOrders.size} órdenes desde Room cache&quot;)&#10;&#10;                // Convertir OrderEntity a Compra&#10;                val comprasFromCache = cachedOrders.mapNotNull { orderEntity -&gt;&#10;                    try {&#10;                        entityToCompra(orderEntity, database)&#10;                    } catch (e: Exception) {&#10;                        Log.w(TAG, &quot;Error convirtiendo orden ${orderEntity.id}: ${e.message}&quot;)&#10;                        null&#10;                    }&#10;                }&#10;&#10;                // Intentar actualizar desde API en background (sin bloquear)&#10;                actualizarHistorialDesdeAPI(context, database, userId)&#10;&#10;                return Result.Success(comprasFromCache, isFromCache = true, isCacheExpired = false)&#10;            }&#10;&#10;            // 2. Si no hay cache, intentar desde API&#10;            val hasInternet = NetworkUtils.isNetworkAvailable(context) &amp;&amp; !ApiClient.forceOfflineMode&#10;&#10;            if (hasInternet) {&#10;                Log.d(TAG, &quot; Sin caché, obteniendo historial de la API...&quot;)&#10;                return obtenerYGuardarDesdeAPI(context, database, userId)&#10;            } else {&#10;                Log.d(TAG, &quot; Sin internet y sin caché local&quot;)&#10;                return Result.Error(&quot;No hay conexión a internet y no hay datos guardados&quot;)&#10;            }&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;❌ Error: ${e.message}&quot;)&#10;            Result.Error(e.message ?: &quot;Error de conexión&quot;)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Actualiza el historial desde la API en background&#10;     */&#10;    private suspend fun actualizarHistorialDesdeAPI(context: Context, database: AppDatabase, userId: Int) {&#10;        try {&#10;            if (NetworkUtils.isNetworkAvailable(context) &amp;&amp; !ApiClient.forceOfflineMode) {&#10;                val response = api.historialCompras(&quot;Bearer ${ApiClient.getToken()}&quot;)&#10;                if (response.isSuccessful &amp;&amp; response.body() != null) {&#10;                    val compras = response.body()!!&#10;                    guardarComprasEnRoom(compras, database, userId)&#10;                    Log.d(TAG, &quot;✅ Historial actualizado desde API en background&quot;)&#10;                }&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.w(TAG, &quot;⚠️ No se pudo actualizar desde API: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Obtiene desde API y guarda en Room&#10;     */&#10;    private suspend fun obtenerYGuardarDesdeAPI(context: Context, database: AppDatabase, userId: Int): Result&lt;List&lt;Compra&gt;&gt; {&#10;        return try {&#10;            val response = api.historialCompras(&quot;Bearer ${ApiClient.getToken()}&quot;)&#10;            if (response.isSuccessful &amp;&amp; response.body() != null) {&#10;                val compras = response.body()!!&#10;                guardarComprasEnRoom(compras, database, userId)&#10;                Log.d(TAG, &quot;✅ ${compras.size} compras obtenidas de API y guardadas en Room&quot;)&#10;                Result.Success(compras, isFromCache = false, isCacheExpired = false)&#10;            } else {&#10;                Result.Error(&quot;Error al obtener historial: ${response.code()}&quot;)&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;❌ Error en API: ${e.message}&quot;)&#10;            Result.Error(e.message ?: &quot;Error de conexión&quot;)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Guarda compras en Room&#10;     */&#10;    private suspend fun guardarComprasEnRoom(compras: List&lt;Compra&gt;, database: AppDatabase, userId: Int) {&#10;        compras.forEach { compra -&gt;&#10;            try {&#10;                val orderEntity = OrderEntity(&#10;                    id = compra.id,&#10;                    status = compra.estado.name,&#10;                    total = compra.total,&#10;                    createdAt = System.currentTimeMillis(),&#10;                    readyAt = null,&#10;                    deliveredAt = null,&#10;                    userId = userId&#10;                )&#10;&#10;                val orderItems = compra.detalles.map { detalle -&gt;&#10;                    OrderItemEntity(&#10;                        orderId = compra.id,&#10;                        productId = detalle.producto.id,&#10;                        name = detalle.producto.nombre,&#10;                        quantity = detalle.cantidad,&#10;                        price = detalle.precioUnitarioCompra&#10;                    )&#10;                }&#10;&#10;                database.orderDao().insertOrderWithItems(orderEntity, orderItems)&#10;            } catch (e: Exception) {&#10;                Log.w(TAG, &quot;Error guardando orden ${compra.id}: ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Convierte OrderEntity a Compra&#10;     */&#10;    private suspend fun entityToCompra(orderEntity: OrderEntity, database: AppDatabase): Compra {&#10;        val items = database.orderDao().getOrderItems(orderEntity.id)&#10;&#10;        // Crear una compra básica desde la entidad&#10;        return Compra(&#10;            id = orderEntity.id,&#10;            fechaHora = orderEntity.createdAt.toString(),&#10;            total = orderEntity.total,&#10;            estado = when (orderEntity.status) {&#10;                &quot;LISTO&quot; -&gt; EstadoCompra.LISTO&#10;                &quot;ENTREGADO&quot; -&gt; EstadoCompra.ENTREGADO&#10;                &quot;EN_PREPARACION&quot; -&gt; EstadoCompra.EN_PREPARACION&#10;                &quot;PAGADO&quot; -&gt; EstadoCompra.PAGADO&#10;                else -&gt; EstadoCompra.CARRITO&#10;            },&#10;            detalles = items.map { item -&gt;&#10;                DetalleCompraResponse(&#10;                    idProducto = item.productId,&#10;                    cantidad = item.quantity,&#10;                    precioUnitarioCompra = item.price,&#10;                    producto = Producto(&#10;                        id = item.productId,&#10;                        nombre = item.name,&#10;                        descripcion = &quot;&quot;,&#10;                        imagenUrl = null,&#10;                        precio = item.price,&#10;                        disponible = true,&#10;                        idTipo = 1,&#10;                        tipoProducto = TipoProducto(1, &quot;General&quot;)&#10;                    )&#10;                )&#10;            },&#10;            qr = null,&#10;            fechaEnPreparacion = null,&#10;            fechaListo = null,&#10;            fechaEntregado = null,&#10;            tiempoHastaPreparacion = null,&#10;            tiempoPreparacion = null,&#10;            tiempoEsperaEntrega = null,&#10;            tiempoTotal = null&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Crea una nueva compra&#10;     * Soporta modo offline guardando en outbox&#10;     */&#10;    suspend fun crearCompra(context: Context, compraRequest: CompraRequest): Result&lt;Compra&gt; {&#10;        val database = AppDatabase.getDatabase(context)&#10;        val dataStore = DataStoreManager(context)&#10;        val userId = dataStore.userId.first() ?: 0&#10;        val hasInternet = NetworkUtils.isNetworkAvailable(context) &amp;&amp; !ApiClient.forceOfflineMode&#10;&#10;        // ✅ SI NO HAY INTERNET, GUARDAR EN OUTBOX DIRECTAMENTE (SIN INTENTAR CONECTAR)&#10;        if (!hasInternet) {&#10;            Log.d(TAG, &quot; Sin internet detectado, guardando en outbox...&quot;)&#10;&#10;            return try {&#10;                val outboxEntry = OrderOutboxEntity(&#10;                    payloadJson = gson.toJson(compraRequest),&#10;                    createdAt = System.currentTimeMillis(),&#10;                    retries = 0&#10;                )&#10;&#10;                database.orderOutboxDao().insert(outboxEntry)&#10;&#10;                Log.d(TAG, &quot; Orden guardada en outbox para sincronizar después&quot;)&#10;                Result.Error(&quot;Sin conexión. Tu orden se guardó y se procesará cuando tengas internet.&quot;)&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;❌ Error guardando en outbox: ${e.message}&quot;)&#10;                Result.Error(&quot;Error al guardar la orden: ${e.message}&quot;)&#10;            }&#10;        }&#10;&#10;        // CON INTERNET: Intentar enviar a API&#10;        return try {&#10;            val response = api.crearCompra(&quot;Bearer ${ApiClient.getToken()}&quot;, compraRequest)&#10;            if (response.isSuccessful &amp;&amp; response.body() != null) {&#10;                val compra = response.body()!!&#10;&#10;                // Guardar en Room&#10;                val orderEntity = OrderEntity(&#10;                    id = compra.id,&#10;                    status = compra.estado.name,&#10;                    total = compra.total,&#10;                    createdAt = System.currentTimeMillis(),&#10;                    userId = userId&#10;                )&#10;&#10;                val orderItems = compraRequest.productos.map { detalle -&gt;&#10;                    OrderItemEntity(&#10;                        orderId = compra.id,&#10;                        productId = detalle.idProducto,&#10;                        name = &quot;Producto ${detalle.idProducto}&quot;,&#10;                        quantity = detalle.cantidad,&#10;                        price = 0.0 // Se actualizará con el total&#10;                    )&#10;                }&#10;&#10;                database.orderDao().insertOrderWithItems(orderEntity, orderItems)&#10;&#10;                // Guardar en DataStore&#10;                dataStore.saveLastOrder(compra.id, compra.total)&#10;&#10;                Log.d(TAG, &quot;✅ Compra creada exitosamente: ID ${compra.id}&quot;)&#10;                Result.Success(compra, isFromCache = false, isCacheExpired = false)&#10;            } else {&#10;                Result.Error(&quot;Error al crear compra: ${response.code()}&quot;)&#10;            }&#10;        } catch (e: Exception) {&#10;            // SI FALLA LA CONEXIÓN, GUARDAR EN OUTBOX COMO RESPALDO&#10;            Log.e(TAG, &quot;❌ Error al conectar con API: ${e.message}, guardando en outbox...&quot;)&#10;&#10;            try {&#10;                val outboxEntry = OrderOutboxEntity(&#10;                    payloadJson = gson.toJson(compraRequest),&#10;                    createdAt = System.currentTimeMillis(),&#10;                    retries = 0&#10;                )&#10;&#10;                database.orderOutboxDao().insert(outboxEntry)&#10;&#10;                Log.d(TAG, &quot; Orden guardada en outbox después de fallo de conexión&quot;)&#10;                Result.Error(&quot;Sin conexión. Tu orden se guardó y se procesará cuando tengas internet.&quot;)&#10;            } catch (outboxError: Exception) {&#10;                Log.e(TAG, &quot;❌ Error guardando en outbox después de fallo: ${outboxError.message}&quot;)&#10;                Result.Error(&quot;Error al procesar la compra: ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Actualiza el estado de una compra (requiere internet)&#10;     */&#10;    suspend fun actualizarEstado(&#10;        context: Context,&#10;        compraId: Int,&#10;        nuevoEstado: String&#10;    ): Result&lt;Compra&gt; {&#10;        return try {&#10;            if (!NetworkUtils.isNetworkAvailable(context)) {&#10;                return Result.Error(&quot;No hay conexión a internet&quot;)&#10;            }&#10;&#10;            val response = api.actualizarEstadoCompra(&#10;                compraId,&#10;                ActualizarEstadoRequest(nuevoEstado)&#10;            )&#10;&#10;            if (response.isSuccessful &amp;&amp; response.body() != null) {&#10;                Result.Success(response.body()!!, isFromCache = false, isCacheExpired = false)&#10;            } else {&#10;                Result.Error(&quot;Error al actualizar estado: ${response.code()}&quot;)&#10;            }&#10;        } catch (e: Exception) {&#10;            Result.Error(e.message ?: &quot;Error de conexión&quot;)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Escanea un código QR para validar y entregar un pedido&#10;     * Solo funciona con internet (staff validation)&#10;     */&#10;    suspend fun escanearQR(codigoQR: String): Result&lt;EscanearQRResponse&gt; {&#10;        return try {&#10;            val response = api.escanearQR(EscanearQRRequest(codigoQR))&#10;&#10;            if (response.isSuccessful &amp;&amp; response.body() != null) {&#10;                Log.d(TAG, &quot;✅ QR escaneado exitosamente&quot;)&#10;                Result.Success(response.body()!!, isFromCache = false, isCacheExpired = false)&#10;            } else {&#10;                val errorMsg = when (response.code()) {&#10;                    404 -&gt; &quot;Código QR no válido o no encontrado&quot;&#10;                    400 -&gt; &quot;El código QR ya fue canjeado o no está listo&quot;&#10;                    else -&gt; &quot;Error al escanear QR: ${response.code()}&quot;&#10;                }&#10;                Log.e(TAG, &quot;❌ Error al escanear QR: ${response.code()}&quot;)&#10;                Result.Error(errorMsg)&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;❌ Error al escanear QR: ${e.message}&quot;)&#10;            Result.Error(e.message ?: &quot;Error de conexión&quot;)&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package app.src.data.repositories&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import app.src.data.api.ApiClient&#10;import app.src.data.models.Compra&#10;import app.src.data.models.CompraRequest&#10;import app.src.data.models.ActualizarEstadoRequest&#10;import app.src.data.models.EscanearQRRequest&#10;import app.src.data.models.EscanearQRResponse&#10;import app.src.data.models.EstadoCompra&#10;import app.src.data.models.DetalleCompraResponse&#10;import app.src.data.models.Producto&#10;import app.src.data.models.TipoProducto&#10;import app.src.utils.NetworkUtils&#10;import app.src.utils.CartManager&#10;import app.src.data.local.AppDatabase&#10;import app.src.data.local.DataStoreManager&#10;import app.src.data.local.entities.OrderEntity&#10;import app.src.data.local.entities.OrderItemEntity&#10;import app.src.data.local.entities.OrderOutboxEntity&#10;import com.google.gson.Gson&#10;import kotlinx.coroutines.flow.first&#10;&#10;class CompraRepository {&#10;&#10;    private val api = ApiClient.compraService&#10;    private val TAG = &quot;CompraRepository&quot;&#10;    private val gson = Gson()&#10;&#10;    /**&#10;     * Obtiene el historial de compras del usuario&#10;     * Estrategia Cache-First: Lee de Room primero, actualiza desde API en background&#10;     */&#10;    suspend fun obtenerHistorial(context: Context): Result&lt;List&lt;Compra&gt;&gt; {&#10;        return try {&#10;            val database = AppDatabase.getDatabase(context)&#10;            val dataStore = DataStoreManager(context)&#10;            val userId = dataStore.userId.first() ?: 0&#10;&#10;            // 1. Leer desde Room primero (instantáneo)&#10;            val cachedOrders = database.orderDao().getOrdersByUser(userId).first()&#10;&#10;            if (cachedOrders.isNotEmpty()) {&#10;                Log.d(TAG, &quot; Cargando ${cachedOrders.size} órdenes desde Room cache&quot;)&#10;&#10;                // Convertir OrderEntity a Compra&#10;                val comprasFromCache = cachedOrders.mapNotNull { orderEntity -&gt;&#10;                    try {&#10;                        entityToCompra(orderEntity, database)&#10;                    } catch (e: Exception) {&#10;                        Log.w(TAG, &quot;Error convirtiendo orden ${orderEntity.id}: ${e.message}&quot;)&#10;                        null&#10;                    }&#10;                }&#10;&#10;                // Intentar actualizar desde API en background (sin bloquear)&#10;                actualizarHistorialDesdeAPI(context, database, userId)&#10;&#10;                return Result.Success(comprasFromCache, isFromCache = true, isCacheExpired = false)&#10;            }&#10;&#10;            // 2. Si no hay cache, intentar desde API&#10;            val hasInternet = NetworkUtils.isNetworkAvailable(context) &amp;&amp; !ApiClient.forceOfflineMode&#10;&#10;            if (hasInternet) {&#10;                Log.d(TAG, &quot; Sin caché, obteniendo historial de la API...&quot;)&#10;                return obtenerYGuardarDesdeAPI(context, database, userId)&#10;            } else {&#10;                Log.d(TAG, &quot; Sin internet y sin caché local&quot;)&#10;                return Result.Error(&quot;No hay conexión a internet y no hay datos guardados&quot;)&#10;            }&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;❌ Error: ${e.message}&quot;)&#10;            Result.Error(e.message ?: &quot;Error de conexión&quot;)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Actualiza el historial desde la API en background&#10;     */&#10;    private suspend fun actualizarHistorialDesdeAPI(context: Context, database: AppDatabase, userId: Int) {&#10;        try {&#10;            if (NetworkUtils.isNetworkAvailable(context) &amp;&amp; !ApiClient.forceOfflineMode) {&#10;                val response = api.historialCompras(&quot;Bearer ${ApiClient.getToken()}&quot;)&#10;                if (response.isSuccessful &amp;&amp; response.body() != null) {&#10;                    val compras = response.body()!!&#10;                    guardarComprasEnRoom(compras, database, userId)&#10;                    Log.d(TAG, &quot;✅ Historial actualizado desde API en background&quot;)&#10;                }&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.w(TAG, &quot;⚠️ No se pudo actualizar desde API: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Obtiene desde API y guarda en Room&#10;     */&#10;    private suspend fun obtenerYGuardarDesdeAPI(context: Context, database: AppDatabase, userId: Int): Result&lt;List&lt;Compra&gt;&gt; {&#10;        return try {&#10;            val response = api.historialCompras(&quot;Bearer ${ApiClient.getToken()}&quot;)&#10;            if (response.isSuccessful &amp;&amp; response.body() != null) {&#10;                val compras = response.body()!!&#10;                guardarComprasEnRoom(compras, database, userId)&#10;                Log.d(TAG, &quot;✅ ${compras.size} compras obtenidas de API y guardadas en Room&quot;)&#10;                Result.Success(compras, isFromCache = false, isCacheExpired = false)&#10;            } else {&#10;                Result.Error(&quot;Error al obtener historial: ${response.code()}&quot;)&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;❌ Error en API: ${e.message}&quot;)&#10;            Result.Error(e.message ?: &quot;Error de conexión&quot;)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Guarda compras en Room&#10;     */&#10;    private suspend fun guardarComprasEnRoom(compras: List&lt;Compra&gt;, database: AppDatabase, userId: Int) {&#10;        compras.forEach { compra -&gt;&#10;            try {&#10;                val orderEntity = OrderEntity(&#10;                    id = compra.id,&#10;                    status = compra.estado.name,&#10;                    total = compra.total,&#10;                    createdAt = System.currentTimeMillis(),&#10;                    readyAt = null,&#10;                    deliveredAt = null,&#10;                    userId = userId,&#10;                    qrCode = compra.qr?.codigoQrHash // ✅ Guardar QR en Room&#10;                )&#10;&#10;                val orderItems = compra.detalles.map { detalle -&gt;&#10;                    OrderItemEntity(&#10;                        orderId = compra.id,&#10;                        productId = detalle.producto.id,&#10;                        name = detalle.producto.nombre,&#10;                        quantity = detalle.cantidad,&#10;                        price = detalle.precioUnitarioCompra&#10;                    )&#10;                }&#10;&#10;                database.orderDao().insertOrderWithItems(orderEntity, orderItems)&#10;            } catch (e: Exception) {&#10;                Log.w(TAG, &quot;Error guardando orden ${compra.id}: ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Convierte OrderEntity a Compra&#10;     */&#10;    private suspend fun entityToCompra(orderEntity: OrderEntity, database: AppDatabase): Compra {&#10;        val items = database.orderDao().getOrderItems(orderEntity.id)&#10;&#10;        // ✅ Generar QR offline si no existe&#10;        val qrCode = orderEntity.qrCode ?: generarQROffline(orderEntity.id)&#10;&#10;        // Crear una compra básica desde la entidad&#10;        return Compra(&#10;            id = orderEntity.id,&#10;            fechaHora = orderEntity.createdAt.toString(),&#10;            total = orderEntity.total,&#10;            estado = when (orderEntity.status) {&#10;                &quot;LISTO&quot; -&gt; EstadoCompra.LISTO&#10;                &quot;ENTREGADO&quot; -&gt; EstadoCompra.ENTREGADO&#10;                &quot;EN_PREPARACION&quot; -&gt; EstadoCompra.EN_PREPARACION&#10;                &quot;PAGADO&quot; -&gt; EstadoCompra.PAGADO&#10;                &quot;PENDIENTE_SINCRONIZAR&quot; -&gt; EstadoCompra.PAGADO // Mostrar como PAGADO&#10;                else -&gt; EstadoCompra.CARRITO&#10;            },&#10;            detalles = items.map { item -&gt;&#10;                DetalleCompraResponse(&#10;                    idProducto = item.productId,&#10;                    cantidad = item.quantity,&#10;                    precioUnitarioCompra = item.price,&#10;                    producto = Producto(&#10;                        id = item.productId,&#10;                        nombre = item.name,&#10;                        descripcion = &quot;&quot;,&#10;                        imagenUrl = null,&#10;                        precio = item.price,&#10;                        disponible = true,&#10;                        idTipo = 1,&#10;                        tipoProducto = TipoProducto(1, &quot;General&quot;)&#10;                    )&#10;                )&#10;            },&#10;            qr = app.src.data.models.QR(&#10;                codigoQrHash = qrCode,&#10;                estado = app.src.data.models.EstadoQR.ACTIVO&#10;            ), // ✅ Incluir QR (generado offline o desde la BD)&#10;            fechaEnPreparacion = null,&#10;            fechaListo = null,&#10;            fechaEntregado = null,&#10;            tiempoHastaPreparacion = null,&#10;            tiempoPreparacion = null,&#10;            tiempoEsperaEntrega = null,&#10;            tiempoTotal = null&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Genera un código QR offline para órdenes que no tienen uno&#10;     * Formato: ORDER_{orderId}_{timestamp}&#10;     */&#10;    private fun generarQROffline(orderId: Int): String {&#10;        val timestamp = System.currentTimeMillis()&#10;        return &quot;OFFLINE_ORDER_${orderId}_${timestamp}&quot;&#10;    }&#10;&#10;    /**&#10;     * Crea una nueva compra&#10;     * Soporta modo offline guardando en outbox&#10;     */&#10;    suspend fun crearCompra(context: Context, compraRequest: CompraRequest): Result&lt;Compra&gt; {&#10;        val database = AppDatabase.getDatabase(context)&#10;        val dataStore = DataStoreManager(context)&#10;        val userId = dataStore.userId.first() ?: 0&#10;        val hasInternet = NetworkUtils.isNetworkAvailable(context) &amp;&amp; !ApiClient.forceOfflineMode&#10;&#10;        // ✅ SI NO HAY INTERNET, GUARDAR EN OUTBOX DIRECTAMENTE (SIN INTENTAR CONECTAR)&#10;        if (!hasInternet) {&#10;            Log.d(TAG, &quot; Sin internet detectado, guardando en outbox...&quot;)&#10;&#10;            return try {&#10;                val currentTime = System.currentTimeMillis()&#10;&#10;                // 1. Guardar en outbox para sincronizar después&#10;                val outboxEntry = OrderOutboxEntity(&#10;                    payloadJson = gson.toJson(compraRequest),&#10;                    createdAt = currentTime,&#10;                    retries = 0&#10;                )&#10;                val outboxId = database.orderOutboxDao().insert(outboxEntry)&#10;&#10;                // 2. ✅ OBTENER EL SIGUIENTE ID DE ORDEN (continúa desde la última orden)&#10;                val maxOrderId = database.orderDao().getMaxOrderId() ?: 0&#10;                val nextOrderId = maxOrderId + 1&#10;&#10;                Log.d(TAG, &quot; Último ID de orden: $maxOrderId, nuevo ID: $nextOrderId&quot;)&#10;&#10;                // Calcular total estimado desde los productos del carrito&#10;                val estimatedTotal = CartManager.getTotal()&#10;&#10;                val tempOrderEntity = OrderEntity(&#10;                    id = nextOrderId,&#10;                    status = &quot;PENDIENTE_SINCRONIZAR&quot;, // Estado especial para órdenes offline&#10;                    total = estimatedTotal,&#10;                    createdAt = currentTime,&#10;                    readyAt = null,&#10;                    deliveredAt = null,&#10;                    userId = userId&#10;                )&#10;&#10;                // 3. Crear items de la orden&#10;                val orderItems = compraRequest.productos.mapNotNull { detalle -&gt;&#10;                    // Buscar el producto en el carrito para obtener su información&#10;                    val cartItem = CartManager.getItems().find { it.producto.id == detalle.idProducto }&#10;                    cartItem?.let {&#10;                        OrderItemEntity(&#10;                            orderId = nextOrderId,&#10;                            productId = detalle.idProducto,&#10;                            name = it.producto.nombre,&#10;                            quantity = detalle.cantidad,&#10;                            price = it.producto.precio&#10;                        )&#10;                    }&#10;                }&#10;&#10;                // 4. Guardar orden temporal en Room&#10;                database.orderDao().insertOrderWithItems(tempOrderEntity, orderItems)&#10;&#10;                Log.d(TAG, &quot; Orden temporal ID:$nextOrderId guardada en historial (pendiente de sincronizar)&quot;)&#10;                Log.d(TAG, &quot; Orden guardada en outbox ID:$outboxId para sincronizar después&quot;)&#10;&#10;                Result.Error(&quot;Sin conexión. Tu orden se guardó y se procesará cuando tengas internet.&quot;)&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;❌ Error guardando en outbox: ${e.message}&quot;)&#10;                Result.Error(&quot;Error al guardar la orden: ${e.message}&quot;)&#10;            }&#10;        }&#10;&#10;        // CON INTERNET: Intentar enviar a API&#10;        return try {&#10;            val response = api.crearCompra(&quot;Bearer ${ApiClient.getToken()}&quot;, compraRequest)&#10;            if (response.isSuccessful &amp;&amp; response.body() != null) {&#10;                val compra = response.body()!!&#10;&#10;                // Guardar en Room&#10;                val orderEntity = OrderEntity(&#10;                    id = compra.id,&#10;                    status = compra.estado.name,&#10;                    total = compra.total,&#10;                    createdAt = System.currentTimeMillis(),&#10;                    userId = userId&#10;                )&#10;&#10;                val orderItems = compraRequest.productos.map { detalle -&gt;&#10;                    OrderItemEntity(&#10;                        orderId = compra.id,&#10;                        productId = detalle.idProducto,&#10;                        name = &quot;Producto ${detalle.idProducto}&quot;,&#10;                        quantity = detalle.cantidad,&#10;                        price = 0.0 // Se actualizará con el total&#10;                    )&#10;                }&#10;&#10;                database.orderDao().insertOrderWithItems(orderEntity, orderItems)&#10;&#10;                // Guardar en DataStore&#10;                dataStore.saveLastOrder(compra.id, compra.total)&#10;&#10;                Log.d(TAG, &quot;✅ Compra creada exitosamente: ID ${compra.id}&quot;)&#10;                Result.Success(compra, isFromCache = false, isCacheExpired = false)&#10;            } else {&#10;                Result.Error(&quot;Error al crear compra: ${response.code()}&quot;)&#10;            }&#10;        } catch (e: Exception) {&#10;            // ✅ DETECTAR ERRORES DE CONEXIÓN Y GUARDAR EN OUTBOX AUTOMÁTICAMENTE&#10;            val isConnectionError = e.message?.contains(&quot;failed to connect&quot;, ignoreCase = true) == true ||&#10;                    e.message?.contains(&quot;Unable to resolve host&quot;, ignoreCase = true) == true ||&#10;                    e.message?.contains(&quot;timeout&quot;, ignoreCase = true) == true ||&#10;                    e is java.net.ConnectException ||&#10;                    e is java.net.SocketTimeoutException ||&#10;                    e is java.net.UnknownHostException&#10;&#10;            if (isConnectionError) {&#10;                Log.w(TAG, &quot; Servidor no accesible, guardando orden en outbox...&quot;)&#10;&#10;                try {&#10;                    val currentTime = System.currentTimeMillis()&#10;&#10;                    // 1. Guardar en outbox para sincronizar después&#10;                    val outboxEntry = OrderOutboxEntity(&#10;                        payloadJson = gson.toJson(compraRequest),&#10;                        createdAt = currentTime,&#10;                        retries = 0&#10;                    )&#10;                    val outboxId = database.orderOutboxDao().insert(outboxEntry)&#10;&#10;                    // 2. ✅ OBTENER EL SIGUIENTE ID DE ORDEN (continúa desde la última orden)&#10;                    val maxOrderId = database.orderDao().getMaxOrderId() ?: 0&#10;                    val nextOrderId = maxOrderId + 1&#10;&#10;                    Log.d(TAG, &quot; Último ID de orden: $maxOrderId, nuevo ID: $nextOrderId&quot;)&#10;&#10;                    val estimatedTotal = CartManager.getTotal()&#10;&#10;                    val tempOrderEntity = OrderEntity(&#10;                        id = nextOrderId,&#10;                        status = &quot;PENDIENTE_SINCRONIZAR&quot;,&#10;                        total = estimatedTotal,&#10;                        createdAt = currentTime,&#10;                        readyAt = null,&#10;                        deliveredAt = null,&#10;                        userId = userId&#10;                    )&#10;&#10;                    // 3. Crear items de la orden&#10;                    val orderItems = compraRequest.productos.mapNotNull { detalle -&gt;&#10;                        val cartItem = CartManager.getItems().find { it.producto.id == detalle.idProducto }&#10;                        cartItem?.let {&#10;                            OrderItemEntity(&#10;                                orderId = nextOrderId,&#10;                                productId = detalle.idProducto,&#10;                                name = it.producto.nombre,&#10;                                quantity = detalle.cantidad,&#10;                                price = it.producto.precio&#10;                            )&#10;                        }&#10;                    }&#10;&#10;                    // 4. Guardar orden temporal en Room&#10;                    database.orderDao().insertOrderWithItems(tempOrderEntity, orderItems)&#10;&#10;                    Log.d(TAG, &quot; Orden temporal ID:$nextOrderId guardada en historial (servidor no disponible)&quot;)&#10;                    Log.d(TAG, &quot; Orden guardada en outbox ID:$outboxId para sincronizar después&quot;)&#10;&#10;                    return Result.Error(&quot;El servidor no está disponible. Tu orden se guardó y se procesará cuando haya conexión.&quot;)&#10;                } catch (outboxError: Exception) {&#10;                    Log.e(TAG, &quot;❌ Error guardando en outbox: ${outboxError.message}&quot;)&#10;                    return Result.Error(&quot;No se pudo guardar la orden: ${outboxError.message}&quot;)&#10;                }&#10;            }&#10;&#10;            // SI NO ES ERROR DE CONEXIÓN, REPORTAR EL ERROR ORIGINAL&#10;            Log.e(TAG, &quot;❌ Error al crear compra: ${e.message}&quot;)&#10;            Result.Error(&quot;Error al procesar la compra: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Actualiza el estado de una compra&#10;     * ✅ FUNCIONA OFFLINE: Guarda el cambio localmente y sincroniza después&#10;     */&#10;    suspend fun actualizarEstado(&#10;        context: Context,&#10;        compraId: Int,&#10;        nuevoEstado: String&#10;    ): Result&lt;Compra&gt; {&#10;        val database = AppDatabase.getDatabase(context)&#10;        val hasInternet = NetworkUtils.isNetworkAvailable(context) &amp;&amp; !ApiClient.forceOfflineMode&#10;&#10;        return try {&#10;            if (hasInternet) {&#10;                // CON INTERNET: Actualizar en el servidor&#10;                val response = api.actualizarEstadoCompra(&#10;                    compraId,&#10;                    ActualizarEstadoRequest(nuevoEstado)&#10;                )&#10;&#10;                if (response.isSuccessful &amp;&amp; response.body() != null) {&#10;                    val compra = response.body()!!&#10;                    &#10;                    // Actualizar también en Room&#10;                    database.orderDao().updateOrderStatus(compraId, nuevoEstado, System.currentTimeMillis())&#10;                    &#10;                    Log.d(TAG, &quot;✅ Estado actualizado en servidor y localmente: $nuevoEstado&quot;)&#10;                    Result.Success(compra, isFromCache = false, isCacheExpired = false)&#10;                } else {&#10;                    Result.Error(&quot;Error al actualizar estado: ${response.code()}&quot;)&#10;                }&#10;            } else {&#10;                // ✅ SIN INTERNET: Guardar cambio localmente&#10;                Log.d(TAG, &quot; Sin conexión, guardando cambio de estado localmente&quot;)&#10;                &#10;                // Actualizar estado en Room&#10;                database.orderDao().updateOrderStatus(compraId, nuevoEstado, System.currentTimeMillis())&#10;                &#10;                // Obtener la orden actualizada para devolver&#10;                val orderEntity = database.orderDao().getOrderById(compraId)&#10;                &#10;                if (orderEntity != null) {&#10;                    val compraActualizada = entityToCompra(orderEntity, database)&#10;                    Log.d(TAG, &quot;✅ Estado actualizado localmente a: $nuevoEstado (se sincronizará después)&quot;)&#10;                    &#10;                    // Retornar Success con un mensaje informativo&#10;                    Result.Success(compraActualizada, isFromCache = true, isCacheExpired = false)&#10;                } else {&#10;                    Result.Error(&quot;Orden no encontrada&quot;)&#10;                }&#10;            }&#10;        } catch (e: Exception) {&#10;            // Si hay error de conexión, intentar guardar localmente&#10;            val isConnectionError = e.message?.contains(&quot;failed to connect&quot;, ignoreCase = true) == true ||&#10;                    e.message?.contains(&quot;Unable to resolve host&quot;, ignoreCase = true) == true ||&#10;                    e.message?.contains(&quot;timeout&quot;, ignoreCase = true) == true ||&#10;                    e is java.net.ConnectException ||&#10;                    e is java.net.SocketTimeoutException ||&#10;                    e is java.net.UnknownHostException&#10;&#10;            if (isConnectionError) {&#10;                try {&#10;                    Log.d(TAG, &quot; Error de conexión, guardando estado localmente&quot;)&#10;                    database.orderDao().updateOrderStatus(compraId, nuevoEstado, System.currentTimeMillis())&#10;                    &#10;                    val orderEntity = database.orderDao().getOrderById(compraId)&#10;                    if (orderEntity != null) {&#10;                        val compraActualizada = entityToCompra(orderEntity, database)&#10;                        return Result.Success(compraActualizada, isFromCache = true, isCacheExpired = false)&#10;                    }&#10;                } catch (localError: Exception) {&#10;                    Log.e(TAG, &quot;❌ Error guardando localmente: ${localError.message}&quot;)&#10;                }&#10;            }&#10;            &#10;            Result.Error(e.message ?: &quot;Error de conexión&quot;)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Escanea un código QR para validar y entregar un pedido&#10;     * Solo funciona con internet (staff validation)&#10;     */&#10;    suspend fun escanearQR(codigoQR: String): Result&lt;EscanearQRResponse&gt; {&#10;        return try {&#10;            val response = api.escanearQR(EscanearQRRequest(codigoQR))&#10;&#10;            if (response.isSuccessful &amp;&amp; response.body() != null) {&#10;                Log.d(TAG, &quot;✅ QR escaneado exitosamente&quot;)&#10;                Result.Success(response.body()!!, isFromCache = false, isCacheExpired = false)&#10;            } else {&#10;                val errorMsg = when (response.code()) {&#10;                    404 -&gt; &quot;Código QR no válido o no encontrado&quot;&#10;                    400 -&gt; &quot;El código QR ya fue canjeado o no está listo&quot;&#10;                    else -&gt; &quot;Error al escanear QR: ${response.code()}&quot;&#10;                }&#10;                Log.e(TAG, &quot;❌ Error al escanear QR: ${response.code()}&quot;)&#10;                Result.Error(errorMsg)&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;❌ Error al escanear QR: ${e.message}&quot;)&#10;            Result.Error(e.message ?: &quot;Error de conexión&quot;)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/src/data/repositories/ProductoRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/src/data/repositories/ProductoRepository.kt" />
              <option name="originalContent" value="package app.src.data.repositories&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import app.src.data.api.ApiClient&#10;import app.src.data.models.*&#10;import app.src.utils.NetworkUtils&#10;import app.src.utils.cache.LruCacheManager&#10;import retrofit2.Response&#10;&#10;class ProductoRepository {&#10;&#10;    private val api = ApiClient.productoService&#10;    private val TAG = &quot;ProductoRepository&quot;&#10;&#10;    suspend fun listarProductos(&#10;        context: Context,&#10;        idTipo: Int? = null,&#10;        disponible: Boolean? = true&#10;    ): Result&lt;List&lt;Producto&gt;&gt; {&#10;        return try {&#10;            val cacheManager = LruCacheManager.getInstance(context)&#10;            val cacheKey = cacheManager.generateProductosKey(idTipo, disponible)&#10;&#10;            // 1. Verificar internet PRIMERO&#10;            val hasInternet = NetworkUtils.isNetworkAvailable(context) &amp;&amp; !ApiClient.forceOfflineMode&#10;&#10;            if (hasInternet) {&#10;                // 2. HAY INTERNET: Siempre obtener datos frescos de la API&#10;                Log.d(TAG, &quot; Internet disponible, obteniendo productos frescos de la API...&quot;)&#10;&#10;                try {&#10;                    val response = api.listarProductos(idTipo, disponible)&#10;                    if (response.isSuccessful &amp;&amp; response.body() != null) {&#10;                        val productos = response.body()!!&#10;&#10;                        // Guardar en LRU cache&#10;                        cacheManager.putProductos(cacheKey, productos)&#10;&#10;                        Log.d(TAG, &quot;✅ ${productos.size} productos obtenidos de API y guardados en LRU cache&quot;)&#10;                        Result.Success(productos, isFromCache = false, isCacheExpired = false)&#10;                    } else {&#10;                        // API falló, intentar usar cache como respaldo&#10;                        Log.w(TAG, &quot;⚠️ API respondió con error, intentando usar LRU cache como respaldo...&quot;)&#10;                        usarCacheComoRespaldo(cacheManager, cacheKey)&#10;                    }&#10;                } catch (e: Exception) {&#10;                    // Error en API, intentar usar cache&#10;                    Log.e(TAG, &quot;❌ Error en API: ${e.message}, intentando usar LRU cache...&quot;)&#10;                    usarCacheComoRespaldo(cacheManager, cacheKey)&#10;                }&#10;            } else {&#10;                // 3. NO HAY INTERNET: Usar cache como respaldo&#10;                Log.d(TAG, &quot; Sin internet, buscando productos en LRU cache...&quot;)&#10;                usarCacheComoRespaldo(cacheManager, cacheKey)&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;❌ Error: ${e.message}&quot;)&#10;            Result.Error(e.message ?: &quot;Error de conexión&quot;)&#10;        }&#10;    }&#10;&#10;    private fun usarCacheComoRespaldo(cacheManager: LruCacheManager, cacheKey: String): Result&lt;List&lt;Producto&gt;&gt; {&#10;        val cachedEntry = cacheManager.getProductos(cacheKey)&#10;&#10;        return if (cachedEntry != null) {&#10;            Log.d(TAG, &quot; Usando ${cachedEntry.data.size} productos del LRU cache&quot;)&#10;            Result.Success(cachedEntry.data, isFromCache = true, isCacheExpired = false)&#10;        } else {&#10;            Log.e(TAG, &quot;❌ No hay productos en LRU cache disponibles&quot;)&#10;            Result.Error(&quot;No hay conexión a internet y no hay datos en caché disponibles&quot;)&#10;        }&#10;    }&#10;&#10;    suspend fun obtenerProducto(context: Context, productoId: Int): Result&lt;Producto&gt; {&#10;        return try {&#10;            val cacheManager = LruCacheManager.getInstance(context)&#10;&#10;            // 1. Verificar internet PRIMERO&#10;            val hasInternet = NetworkUtils.isNetworkAvailable(context) &amp;&amp; !ApiClient.forceOfflineMode&#10;&#10;            if (hasInternet) {&#10;                // HAY INTERNET: Siempre obtener de la API&#10;                Log.d(TAG, &quot; Internet disponible, obteniendo producto $productoId de la API...&quot;)&#10;&#10;                val response = api.obtenerProducto(productoId)&#10;                if (response.isSuccessful &amp;&amp; response.body() != null) {&#10;                    val producto = response.body()!!&#10;&#10;                    // Guardar en LRU cache&#10;                    cacheManager.putProducto(productoId, producto)&#10;&#10;                    Log.d(TAG, &quot;✅ Producto $productoId obtenido de API y guardado en LRU cache&quot;)&#10;                    Result.Success(producto, isFromCache = false, isCacheExpired = false)&#10;                } else {&#10;                    usarProductoCacheComoRespaldo(cacheManager, productoId)&#10;                }&#10;            } else {&#10;                // NO HAY INTERNET: Usar cache&#10;                Log.d(TAG, &quot; Sin internet, buscando producto $productoId en LRU cache...&quot;)&#10;                usarProductoCacheComoRespaldo(cacheManager, productoId)&#10;            }&#10;        } catch (e: Exception) {&#10;            Result.Error(e.message ?: &quot;Error de conexión&quot;)&#10;        }&#10;    }&#10;&#10;    private fun usarProductoCacheComoRespaldo(cacheManager: LruCacheManager, productoId: Int): Result&lt;Producto&gt; {&#10;        val cachedEntry = cacheManager.getProducto(productoId)&#10;&#10;        return if (cachedEntry != null) {&#10;            Log.d(TAG, &quot; Usando producto del LRU cache&quot;)&#10;            Result.Success(cachedEntry.data, isFromCache = true, isCacheExpired = false)&#10;        } else {&#10;            Log.e(TAG, &quot;❌ No hay producto en LRU cache disponible&quot;)&#10;            Result.Error(&quot;No hay conexión a internet y no hay datos en caché disponibles&quot;)&#10;        }&#10;    }&#10;&#10;    suspend fun listarTipos(context: Context): Result&lt;List&lt;TipoProducto&gt;&gt; {&#10;        return try {&#10;            val cacheManager = LruCacheManager.getInstance(context)&#10;&#10;            // 1. Verificar internet PRIMERO&#10;            val hasInternet = NetworkUtils.isNetworkAvailable(context) &amp;&amp; !ApiClient.forceOfflineMode&#10;&#10;            if (hasInternet) {&#10;                // HAY INTERNET: Siempre obtener de la API&#10;                Log.d(TAG, &quot; Internet disponible, obteniendo tipos de la API...&quot;)&#10;&#10;                val response = api.listarTipos()&#10;                if (response.isSuccessful &amp;&amp; response.body() != null) {&#10;                    val tipos = response.body()!!&#10;&#10;                    // Guardar en LRU cache&#10;                    cacheManager.putTipos(tipos)&#10;&#10;                    Log.d(TAG, &quot;✅ ${tipos.size} tipos obtenidos de API y guardados en LRU cache&quot;)&#10;                    Result.Success(tipos, isFromCache = false, isCacheExpired = false)&#10;                } else {&#10;                    usarTiposCacheComoRespaldo(cacheManager)&#10;                }&#10;            } else {&#10;                // NO HAY INTERNET: Usar cache&#10;                Log.d(TAG, &quot; Sin internet, buscando tipos en LRU cache...&quot;)&#10;                usarTiposCacheComoRespaldo(cacheManager)&#10;            }&#10;        } catch (e: Exception) {&#10;            Result.Error(e.message ?: &quot;Error de conexión&quot;)&#10;        }&#10;    }&#10;&#10;    private fun usarTiposCacheComoRespaldo(cacheManager: LruCacheManager): Result&lt;List&lt;TipoProducto&gt;&gt; {&#10;        val cachedEntry = cacheManager.getTipos()&#10;&#10;        return if (cachedEntry != null) {&#10;            Log.d(TAG, &quot; Usando ${cachedEntry.data.size} tipos del LRU cache&quot;)&#10;            Result.Success(cachedEntry.data, isFromCache = true, isCacheExpired = false)&#10;        } else {&#10;            Log.e(TAG, &quot;❌ No hay tipos en LRU cache disponibles&quot;)&#10;            Result.Error(&quot;No hay conexión a internet y no hay datos en caché disponibles&quot;)&#10;        }&#10;    }&#10;&#10;    suspend fun obtenerProductosRecomendados(context: Context): Result&lt;List&lt;Producto&gt;&gt; {&#10;        return try {&#10;            val cacheManager = LruCacheManager.getInstance(context)&#10;            val cacheKey = &quot;productos_recomendados&quot;&#10;&#10;            // 1. Verificar internet PRIMERO&#10;            val hasInternet = NetworkUtils.isNetworkAvailable(context) &amp;&amp; !ApiClient.forceOfflineMode&#10;&#10;            if (hasInternet) {&#10;                // HAY INTERNET: Siempre obtener de la API&#10;                Log.d(TAG, &quot; Internet disponible, obteniendo productos recomendados de la API...&quot;)&#10;&#10;                val response = api.obtenerProductosRecomendados()&#10;                if (response.isSuccessful &amp;&amp; response.body() != null) {&#10;                    val productos = response.body()!!&#10;&#10;                    // Guardar en LRU cache&#10;                    cacheManager.putProductos(cacheKey, productos)&#10;&#10;                    Log.d(TAG, &quot;✅ ${productos.size} productos recomendados obtenidos de API y guardados en LRU cache&quot;)&#10;                    Result.Success(productos, isFromCache = false, isCacheExpired = false)&#10;                } else {&#10;                    usarCacheComoRespaldo(cacheManager, cacheKey)&#10;                }&#10;            } else {&#10;                // NO HAY INTERNET: Usar cache&#10;                Log.d(TAG, &quot; Sin internet, buscando productos recomendados en LRU cache...&quot;)&#10;                usarCacheComoRespaldo(cacheManager, cacheKey)&#10;            }&#10;        } catch (e: Exception) {&#10;            Result.Error(e.message ?: &quot;Error de conexión&quot;)&#10;        }&#10;    }&#10;&#10;    private fun parseError(response: Response&lt;*&gt;): String {&#10;        return when (response.code()) {&#10;            400 -&gt; &quot;Datos inválidos&quot;&#10;            404 -&gt; &quot;Producto no encontrado&quot;&#10;            500 -&gt; &quot;Error del servidor&quot;&#10;            else -&gt; &quot;Error: ${response.code()}&quot;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package app.src.data.repositories&#13;&#10;&#13;&#10;import android.content.Context&#13;&#10;import android.util.Log&#13;&#10;import app.src.data.api.ApiClient&#13;&#10;import app.src.data.models.*&#13;&#10;import app.src.utils.NetworkUtils&#13;&#10;import app.src.utils.cache.LruCacheManager&#13;&#10;import retrofit2.Response&#13;&#10;&#13;&#10;class ProductoRepository {&#13;&#10;&#13;&#10;    private val api = ApiClient.productoService&#13;&#10;    private val TAG = &quot;ProductoRepository&quot;&#13;&#10;&#13;&#10;    suspend fun listarProductos(&#13;&#10;        context: Context,&#13;&#10;        idTipo: Int? = null,&#13;&#10;        disponible: Boolean? = true&#13;&#10;    ): Result&lt;List&lt;Producto&gt;&gt; {&#13;&#10;        return try {&#13;&#10;            val cacheManager = LruCacheManager.getInstance(context)&#13;&#10;            val cacheKey = cacheManager.generateProductosKey(idTipo, disponible)&#13;&#10;&#13;&#10;            // 1. Verificar internet PRIMERO&#13;&#10;            val hasInternet = NetworkUtils.isNetworkAvailable(context) &amp;&amp; !ApiClient.forceOfflineMode&#13;&#10;&#13;&#10;            if (hasInternet) {&#13;&#10;                // 2. HAY INTERNET: Siempre obtener datos frescos de la API&#13;&#10;                Log.d(TAG, &quot; Internet disponible, obteniendo productos frescos de la API...&quot;)&#13;&#10;&#13;&#10;                try {&#13;&#10;                    val response = api.listarProductos(idTipo, disponible)&#13;&#10;                    if (response.isSuccessful &amp;&amp; response.body() != null) {&#13;&#10;                        val productos = response.body()!!&#13;&#10;&#13;&#10;                        // Guardar en LRU cache&#13;&#10;                        cacheManager.putProductos(cacheKey, productos)&#13;&#10;&#13;&#10;                        Log.d(TAG, &quot;✅ ${productos.size} productos obtenidos de API y guardados en LRU cache&quot;)&#13;&#10;                        Result.Success(productos, isFromCache = false, isCacheExpired = false)&#13;&#10;                    } else {&#13;&#10;                        // API falló, intentar usar cache como respaldo&#13;&#10;                        Log.w(TAG, &quot;⚠️ API respondió con error, intentando usar LRU cache como respaldo...&quot;)&#13;&#10;                        usarCacheComoRespaldo(cacheManager, cacheKey)&#13;&#10;                    }&#13;&#10;                } catch (e: Exception) {&#13;&#10;                    // Error en API, intentar usar cache&#13;&#10;                    Log.e(TAG, &quot;❌ Error en API: ${e.message}, intentando usar LRU cache...&quot;)&#13;&#10;                    usarCacheComoRespaldo(cacheManager, cacheKey)&#13;&#10;                }&#13;&#10;            } else {&#13;&#10;                // 3. NO HAY INTERNET: Usar cache como respaldo&#13;&#10;                Log.d(TAG, &quot; Sin internet, buscando productos en LRU cache...&quot;)&#13;&#10;                usarCacheComoRespaldo(cacheManager, cacheKey)&#13;&#10;            }&#13;&#10;        } catch (e: Exception) {&#13;&#10;            Log.e(TAG, &quot;❌ Error: ${e.message}&quot;)&#13;&#10;            Result.Error(e.message ?: &quot;Error de conexión&quot;)&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private fun usarCacheComoRespaldo(cacheManager: LruCacheManager, cacheKey: String): Result&lt;List&lt;Producto&gt;&gt; {&#13;&#10;        val cachedEntry = cacheManager.getProductos(cacheKey)&#13;&#10;&#13;&#10;        return if (cachedEntry != null) {&#13;&#10;            Log.d(TAG, &quot; Usando ${cachedEntry.data.size} productos del LRU cache&quot;)&#13;&#10;            Result.Success(cachedEntry.data, isFromCache = true, isCacheExpired = false)&#13;&#10;        } else {&#13;&#10;            Log.e(TAG, &quot;❌ No hay productos en LRU cache disponibles&quot;)&#13;&#10;            Result.Error(&quot;No hay conexión a internet y no hay datos en caché disponibles&quot;)&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    suspend fun obtenerProducto(context: Context, productoId: Int): Result&lt;Producto&gt; {&#13;&#10;        return try {&#13;&#10;            val cacheManager = LruCacheManager.getInstance(context)&#13;&#10;&#13;&#10;            // 1. Verificar internet PRIMERO&#13;&#10;            val hasInternet = NetworkUtils.isNetworkAvailable(context) &amp;&amp; !ApiClient.forceOfflineMode&#13;&#10;&#13;&#10;            if (hasInternet) {&#13;&#10;                // HAY INTERNET: Siempre obtener de la API&#13;&#10;                Log.d(TAG, &quot; Internet disponible, obteniendo producto $productoId de la API...&quot;)&#13;&#10;&#13;&#10;                val response = api.obtenerProducto(productoId)&#13;&#10;                if (response.isSuccessful &amp;&amp; response.body() != null) {&#13;&#10;                    val producto = response.body()!!&#13;&#10;&#13;&#10;                    // Guardar en LRU cache&#13;&#10;                    cacheManager.putProducto(productoId, producto)&#13;&#10;&#13;&#10;                    Log.d(TAG, &quot;✅ Producto $productoId obtenido de API y guardado en LRU cache&quot;)&#13;&#10;                    Result.Success(producto, isFromCache = false, isCacheExpired = false)&#13;&#10;                } else {&#13;&#10;                    usarProductoCacheComoRespaldo(cacheManager, productoId)&#13;&#10;                }&#13;&#10;            } else {&#13;&#10;                // NO HAY INTERNET: Usar cache&#13;&#10;                Log.d(TAG, &quot; Sin internet, buscando producto $productoId en LRU cache...&quot;)&#13;&#10;                usarProductoCacheComoRespaldo(cacheManager, productoId)&#13;&#10;            }&#13;&#10;        } catch (e: Exception) {&#13;&#10;            Result.Error(e.message ?: &quot;Error de conexión&quot;)&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private fun usarProductoCacheComoRespaldo(cacheManager: LruCacheManager, productoId: Int): Result&lt;Producto&gt; {&#13;&#10;        val cachedEntry = cacheManager.getProducto(productoId)&#13;&#10;&#13;&#10;        return if (cachedEntry != null) {&#13;&#10;            Log.d(TAG, &quot; Usando producto del LRU cache&quot;)&#13;&#10;            Result.Success(cachedEntry.data, isFromCache = true, isCacheExpired = false)&#13;&#10;        } else {&#13;&#10;            Log.e(TAG, &quot;❌ No hay producto en LRU cache disponible&quot;)&#13;&#10;            Result.Error(&quot;No hay conexión a internet y no hay datos en caché disponibles&quot;)&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    suspend fun listarTipos(context: Context): Result&lt;List&lt;TipoProducto&gt;&gt; {&#13;&#10;        return try {&#13;&#10;            val cacheManager = LruCacheManager.getInstance(context)&#13;&#10;&#13;&#10;            // 1. Verificar internet PRIMERO&#13;&#10;            val hasInternet = NetworkUtils.isNetworkAvailable(context) &amp;&amp; !ApiClient.forceOfflineMode&#13;&#10;&#13;&#10;            if (hasInternet) {&#13;&#10;                // HAY INTERNET: Siempre obtener de la API&#13;&#10;                Log.d(TAG, &quot; Internet disponible, obteniendo tipos de la API...&quot;)&#13;&#10;&#13;&#10;                val response = api.listarTipos()&#13;&#10;                if (response.isSuccessful &amp;&amp; response.body() != null) {&#13;&#10;                    val tipos = response.body()!!&#13;&#10;&#13;&#10;                    // Guardar en LRU cache&#13;&#10;                    cacheManager.putTipos(tipos)&#13;&#10;&#13;&#10;                    Log.d(TAG, &quot;✅ ${tipos.size} tipos obtenidos de API y guardados en LRU cache&quot;)&#13;&#10;                    Result.Success(tipos, isFromCache = false, isCacheExpired = false)&#13;&#10;                } else {&#13;&#10;                    usarTiposCacheComoRespaldo(cacheManager)&#13;&#10;                }&#13;&#10;            } else {&#13;&#10;                // NO HAY INTERNET: Usar cache&#13;&#10;                Log.d(TAG, &quot; Sin internet, buscando tipos en LRU cache...&quot;)&#13;&#10;                usarTiposCacheComoRespaldo(cacheManager)&#13;&#10;            }&#13;&#10;        } catch (e: Exception) {&#13;&#10;            Result.Error(e.message ?: &quot;Error de conexión&quot;)&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private fun usarTiposCacheComoRespaldo(cacheManager: LruCacheManager): Result&lt;List&lt;TipoProducto&gt;&gt; {&#13;&#10;        val cachedEntry = cacheManager.getTipos()&#13;&#10;&#13;&#10;        return if (cachedEntry != null) {&#13;&#10;            Log.d(TAG, &quot; Usando ${cachedEntry.data.size} tipos del LRU cache&quot;)&#13;&#10;            Result.Success(cachedEntry.data, isFromCache = true, isCacheExpired = false)&#13;&#10;        } else {&#13;&#10;            Log.e(TAG, &quot;❌ No hay tipos en LRU cache disponibles&quot;)&#13;&#10;            Result.Error(&quot;No hay conexión a internet y no hay datos en caché disponibles&quot;)&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    suspend fun obtenerProductosRecomendados(context: Context): Result&lt;List&lt;Producto&gt;&gt; {&#13;&#10;        return try {&#13;&#10;            val cacheManager = LruCacheManager.getInstance(context)&#13;&#10;            val cacheKey = &quot;productos_recomendados&quot;&#13;&#10;&#13;&#10;            // 1. Verificar internet PRIMERO&#13;&#10;            val hasInternet = NetworkUtils.isNetworkAvailable(context) &amp;&amp; !ApiClient.forceOfflineMode&#13;&#10;&#13;&#10;            if (hasInternet) {&#13;&#10;                // HAY INTERNET: Siempre obtener de la API&#13;&#10;                Log.d(TAG, &quot; Internet disponible, obteniendo productos recomendados de la API...&quot;)&#13;&#10;&#13;&#10;                try {&#13;&#10;                    val response = api.obtenerProductosRecomendados()&#13;&#10;                    if (response.isSuccessful &amp;&amp; response.body() != null) {&#13;&#10;                        val productos = response.body()!!&#13;&#10;&#13;&#10;                        // Guardar en LRU cache&#13;&#10;                        cacheManager.putProductos(cacheKey, productos)&#13;&#10;&#13;&#10;                        Log.d(TAG, &quot;✅ ${productos.size} productos recomendados obtenidos de API y guardados en LRU cache&quot;)&#13;&#10;                        Result.Success(productos, isFromCache = false, isCacheExpired = false)&#13;&#10;                    } else {&#13;&#10;                        Log.w(TAG, &quot;⚠️ API respondió con código ${response.code()}, usando cache como respaldo&quot;)&#13;&#10;                        usarCacheComoRespaldo(cacheManager, cacheKey)&#13;&#10;                    }&#13;&#10;                } catch (apiError: Exception) {&#13;&#10;                    Log.e(TAG, &quot;❌ Error llamando a la API: ${apiError.javaClass.simpleName}: ${apiError.message}&quot;)&#13;&#10;                    apiError.printStackTrace()&#13;&#10;                    usarCacheComoRespaldo(cacheManager, cacheKey)&#13;&#10;                }&#13;&#10;            } else {&#13;&#10;                // NO HAY INTERNET: Usar cache&#13;&#10;                Log.d(TAG, &quot; Sin internet, buscando productos recomendados en LRU cache...&quot;)&#13;&#10;                usarCacheComoRespaldo(cacheManager, cacheKey)&#13;&#10;            }&#13;&#10;        } catch (e: Exception) {&#13;&#10;            Log.e(TAG, &quot;❌ Error general: ${e.javaClass.simpleName}: ${e.message}&quot;)&#13;&#10;            e.printStackTrace()&#13;&#10;            Result.Error(&quot;Error al cargar productos: ${e.message}&quot;)&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private fun parseError(response: Response&lt;*&gt;): String {&#13;&#10;        return when (response.code()) {&#13;&#10;            400 -&gt; &quot;Datos inválidos&quot;&#13;&#10;            404 -&gt; &quot;Producto no encontrado&quot;&#13;&#10;            500 -&gt; &quot;Error del servidor&quot;&#13;&#10;            else -&gt; &quot;Error: ${response.code()}&quot;&#13;&#10;        }&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/src/data/repositories/UsuarioRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/src/data/repositories/UsuarioRepository.kt" />
              <option name="originalContent" value="package app.src.data.repositories&#10;&#10;import app.src.data.api.ApiClient&#10;import app.src.data.models.*&#10;import retrofit2.Response&#10;&#10;sealed class Result&lt;out T&gt; {&#10;    data class Success&lt;T&gt;(&#10;        val data: T,&#10;        val isFromCache: Boolean = false,&#10;        val isCacheExpired: Boolean = false&#10;    ) : Result&lt;T&gt;()&#10;    data class Error(val message: String, val code: Int? = null) : Result&lt;Nothing&gt;()&#10;    object Loading : Result&lt;Nothing&gt;()&#10;}&#10;&#10;class UsuarioRepository {&#10;&#10;    private val api = ApiClient.usuarioService&#10;&#10;    suspend fun registrarUsuario(nombre: String, email: String, password: String): Result&lt;Usuario&gt; {&#10;        return try {&#10;            val response = api.registrarUsuario(UsuarioCreate(nombre, email, password))&#10;            if (response.isSuccessful &amp;&amp; response.body() != null) {&#10;                Result.Success(response.body()!!)&#10;            } else {&#10;                Result.Error(parseError(response), response.code())&#10;            }&#10;        } catch (e: Exception) {&#10;            Result.Error(e.message ?: &quot;Error de conexión&quot;)&#10;        }&#10;    }&#10;&#10;    suspend fun login(email: String, password: String): Result&lt;TokenResponse&gt; {&#10;        return try {&#10;            val response = api.login(LoginRequest(email, password))&#10;            if (response.isSuccessful &amp;&amp; response.body() != null) {&#10;                val token = response.body()!!&#10;                ApiClient.setToken(token.accessToken)&#10;                Result.Success(token)&#10;            } else {&#10;                Result.Error(parseError(response), response.code())&#10;            }&#10;        } catch (e: Exception) {&#10;            Result.Error(e.message ?: &quot;Error de conexión&quot;)&#10;        }&#10;    }&#10;&#10;    suspend fun obtenerPerfil(): Result&lt;Usuario&gt; {&#10;        return try {&#10;            val token = ApiClient.getToken()&#10;            if (token == null) {&#10;                return Result.Error(&quot;No hay sesión activa&quot;)&#10;            }&#10;&#10;            val response = api.obtenerPerfil(&quot;Bearer $token&quot;)&#10;            if (response.isSuccessful &amp;&amp; response.body() != null) {&#10;                Result.Success(response.body()!!)&#10;            } else {&#10;                Result.Error(parseError(response), response.code())&#10;            }&#10;        } catch (e: Exception) {&#10;            Result.Error(e.message ?: &quot;Error de conexión&quot;)&#10;        }&#10;    }&#10;&#10;    suspend fun recargarSaldo(monto: Double): Result&lt;Usuario&gt; {&#10;        return try {&#10;            val token = ApiClient.getToken()&#10;            if (token == null) {&#10;                return Result.Error(&quot;No hay sesión activa&quot;)&#10;            }&#10;&#10;            val response = api.recargarSaldo(&quot;Bearer $token&quot;, RecargarSaldoRequest(monto))&#10;            if (response.isSuccessful &amp;&amp; response.body() != null) {&#10;                Result.Success(response.body()!!)&#10;            } else {&#10;                Result.Error(parseError(response), response.code())&#10;            }&#10;        } catch (e: Exception) {&#10;            Result.Error(e.message ?: &quot;Error de conexión&quot;)&#10;        }&#10;    }&#10;&#10;    fun logout() {&#10;        ApiClient.setToken(null)&#10;    }&#10;&#10;    private fun parseError(response: Response&lt;*&gt;): String {&#10;        return when (response.code()) {&#10;            400 -&gt; &quot;Datos inválidos&quot;&#10;            401 -&gt; &quot;Credenciales incorrectas&quot;&#10;            404 -&gt; &quot;Usuario no encontrado&quot;&#10;            422 -&gt; &quot;Datos con formato incorrecto&quot;&#10;            500 -&gt; &quot;Error del servidor&quot;&#10;            else -&gt; &quot;Error: ${response.code()}&quot;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package app.src.data.repositories&#13;&#10;&#13;&#10;import app.src.data.api.ApiClient&#13;&#10;import app.src.data.models.*&#13;&#10;import retrofit2.Response&#13;&#10;&#13;&#10;sealed class Result&lt;out T&gt; {&#13;&#10;    data class Success&lt;T&gt;(&#13;&#10;        val data: T,&#13;&#10;        val isFromCache: Boolean = false,&#13;&#10;        val isCacheExpired: Boolean = false&#13;&#10;    ) : Result&lt;T&gt;()&#13;&#10;    data class Error(val message: String, val code: Int? = null) : Result&lt;Nothing&gt;()&#13;&#10;    object Loading : Result&lt;Nothing&gt;()&#13;&#10;}&#13;&#10;&#13;&#10;class UsuarioRepository {&#13;&#10;&#13;&#10;    private val api = ApiClient.usuarioService&#13;&#10;&#13;&#10;    suspend fun registrarUsuario(nombre: String, email: String, password: String): Result&lt;Usuario&gt; {&#13;&#10;        return try {&#13;&#10;            val response = api.registrarUsuario(UsuarioCreate(nombre, email, password))&#13;&#10;            if (response.isSuccessful &amp;&amp; response.body() != null) {&#13;&#10;                Result.Success(response.body()!!)&#13;&#10;            } else {&#13;&#10;                Result.Error(parseError(response), response.code())&#13;&#10;            }&#13;&#10;        } catch (e: Exception) {&#13;&#10;            Result.Error(e.message ?: &quot;Error de conexión&quot;)&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    suspend fun login(email: String, password: String): Result&lt;TokenResponse&gt; {&#13;&#10;        return try {&#13;&#10;            val response = api.login(LoginRequest(email, password))&#13;&#10;            if (response.isSuccessful &amp;&amp; response.body() != null) {&#13;&#10;                val token = response.body()!!&#13;&#10;                ApiClient.setToken(token.accessToken)&#13;&#10;                Result.Success(token)&#13;&#10;            } else {&#13;&#10;                Result.Error(parseError(response), response.code())&#13;&#10;            }&#13;&#10;        } catch (e: Exception) {&#13;&#10;            // ✅ MEJORAR MENSAJE DE ERROR SEGÚN EL TIPO DE EXCEPCIÓN&#13;&#10;            val errorMessage = when {&#13;&#10;                e is java.net.ConnectException ||&#13;&#10;                e.message?.contains(&quot;failed to connect&quot;, ignoreCase = true) == true -&gt;&#13;&#10;                    &quot;Servidor no disponible. Verifica que el backend esté funcionando.&quot;&#13;&#10;                e is java.net.UnknownHostException -&gt;&#13;&#10;                    &quot;No se puede resolver el host. Verifica la URL del servidor.&quot;&#13;&#10;                e is java.net.SocketTimeoutException -&gt;&#13;&#10;                    &quot;Tiempo de espera agotado. El servidor tardó mucho en responder.&quot;&#13;&#10;                else -&gt;&#13;&#10;                    &quot;Error de conexión: ${e.message}&quot;&#13;&#10;            }&#13;&#10;            Result.Error(errorMessage)&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    suspend fun obtenerPerfil(): Result&lt;Usuario&gt; {&#13;&#10;        return try {&#13;&#10;            val token = ApiClient.getToken()&#13;&#10;            if (token == null) {&#13;&#10;                return Result.Error(&quot;No hay sesión activa&quot;)&#13;&#10;            }&#13;&#10;&#13;&#10;            val response = api.obtenerPerfil(&quot;Bearer $token&quot;)&#13;&#10;            if (response.isSuccessful &amp;&amp; response.body() != null) {&#13;&#10;                Result.Success(response.body()!!)&#13;&#10;            } else {&#13;&#10;                Result.Error(parseError(response), response.code())&#13;&#10;            }&#13;&#10;        } catch (e: Exception) {&#13;&#10;            Result.Error(e.message ?: &quot;Error de conexión&quot;)&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    suspend fun recargarSaldo(monto: Double): Result&lt;Usuario&gt; {&#13;&#10;        return try {&#13;&#10;            val token = ApiClient.getToken()&#13;&#10;            if (token == null) {&#13;&#10;                return Result.Error(&quot;No hay sesión activa&quot;)&#13;&#10;            }&#13;&#10;&#13;&#10;            val response = api.recargarSaldo(&quot;Bearer $token&quot;, RecargarSaldoRequest(monto))&#13;&#10;            if (response.isSuccessful &amp;&amp; response.body() != null) {&#13;&#10;                Result.Success(response.body()!!)&#13;&#10;            } else {&#13;&#10;                Result.Error(parseError(response), response.code())&#13;&#10;            }&#13;&#10;        } catch (e: Exception) {&#13;&#10;            Result.Error(e.message ?: &quot;Error de conexión&quot;)&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun logout() {&#13;&#10;        ApiClient.setToken(null)&#13;&#10;    }&#13;&#10;&#13;&#10;    private fun parseError(response: Response&lt;*&gt;): String {&#13;&#10;        return when (response.code()) {&#13;&#10;            400 -&gt; &quot;Datos inválidos&quot;&#13;&#10;            401 -&gt; &quot;Credenciales incorrectas&quot;&#13;&#10;            404 -&gt; &quot;Usuario no encontrado&quot;&#13;&#10;            422 -&gt; &quot;Datos con formato incorrecto&quot;&#13;&#10;            500 -&gt; &quot;Error del servidor&quot;&#13;&#10;            else -&gt; &quot;Error: ${response.code()}&quot;&#13;&#10;        }&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/app/src/utils/CartManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/app/src/utils/CartManager.kt" />
              <option name="originalContent" value="package app.src.utils&#10;&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;import android.util.Log&#10;import app.src.data.models.Producto&#10;import com.google.gson.Gson&#10;import com.google.gson.reflect.TypeToken&#10;&#10;/**&#10; * CartManager - Gestión del Carrito de Compras con Persistencia&#10; *&#10; * Características:&#10; * - Almacenamiento en memoria (rápido) + SharedPreferences (persistente)&#10; * - El carrito NO se pierde al cerrar la app&#10; * - Sincronización automática entre memoria y disco&#10; * - Thread-safe para operaciones concurrentes&#10; */&#10;object CartManager {&#10;&#10;    private const val TAG = &quot;CartManager&quot;&#10;    private const val PREFS_NAME = &quot;CartPreferences&quot;&#10;    private const val KEY_CART_ITEMS = &quot;cart_items&quot;&#10;&#10;    private val gson = Gson()&#10;    private var context: Context? = null&#10;&#10;    data class CartItem(&#10;        val producto: Producto,&#10;        var cantidad: Int = 1&#10;    ) {&#10;        val subtotal: Double&#10;            get() = producto.precio * cantidad&#10;    }&#10;&#10;    // Cache en memoria para acceso rápido&#10;    private val items = mutableMapOf&lt;Int, CartItem&gt;()&#10;&#10;    /**&#10;     * Inicializa el CartManager con el contexto de la aplicación&#10;     * Debe llamarse al inicio de la app (en Application o Activity principal)&#10;     */&#10;    fun init(appContext: Context) {&#10;        context = appContext.applicationContext&#10;        loadFromPreferences()&#10;    }&#10;&#10;    /**&#10;     * Carga el carrito desde SharedPreferences al iniciar&#10;     */&#10;    private fun loadFromPreferences() {&#10;        try {&#10;            val prefs = getPreferences() ?: return&#10;            val json = prefs.getString(KEY_CART_ITEMS, null) ?: return&#10;&#10;            val type = object : TypeToken&lt;Map&lt;Int, CartItem&gt;&gt;() {}.type&#10;            val loadedItems: Map&lt;Int, CartItem&gt; = gson.fromJson(json, type)&#10;&#10;            items.clear()&#10;            items.putAll(loadedItems)&#10;&#10;            Log.d(TAG, &quot;✅ Carrito cargado desde persistencia: ${items.size} items&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;❌ Error al cargar carrito: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Guarda el carrito en SharedPreferences&#10;     */&#10;    private fun saveToPreferences() {&#10;        try {&#10;            val prefs = getPreferences() ?: return&#10;            val json = gson.toJson(items)&#10;&#10;            prefs.edit().putString(KEY_CART_ITEMS, json).apply()&#10;            Log.d(TAG, &quot; Carrito guardado en persistencia&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;❌ Error al guardar carrito: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    private fun getPreferences(): SharedPreferences? {&#10;        return context?.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;    }&#10;&#10;    fun addProduct(producto: Producto, cantidad: Int = 1) {&#10;        val existing = items[producto.id]&#10;        if (existing != null) {&#10;            existing.cantidad += cantidad&#10;        } else {&#10;            items[producto.id] = CartItem(producto, cantidad)&#10;        }&#10;        saveToPreferences() // Persistir cambios&#10;        Log.d(TAG, &quot;➕ Producto agregado: ${producto.nombre} (cantidad: $cantidad)&quot;)&#10;    }&#10;&#10;    fun removeProduct(productoId: Int) {&#10;        items.remove(productoId)&#10;        saveToPreferences() // Persistir cambios&#10;        Log.d(TAG, &quot;➖ Producto eliminado: ID $productoId&quot;)&#10;    }&#10;&#10;    fun updateQuantity(productoId: Int, cantidad: Int) {&#10;        val item = items[productoId]&#10;        if (item != null) {&#10;            if (cantidad &lt;= 0) {&#10;                items.remove(productoId)&#10;            } else {&#10;                item.cantidad = cantidad&#10;            }&#10;            saveToPreferences() // Persistir cambios&#10;            Log.d(TAG, &quot; Cantidad actualizada: ID $productoId → $cantidad&quot;)&#10;        }&#10;    }&#10;&#10;    fun getItems(): List&lt;CartItem&gt; {&#10;        return items.values.toList()&#10;    }&#10;&#10;    fun getTotal(): Double {&#10;        return items.values.sumOf { it.subtotal }&#10;    }&#10;&#10;    fun getItemCount(): Int {&#10;        return items.values.sumOf { it.cantidad }&#10;    }&#10;&#10;    fun clear() {&#10;        items.clear()&#10;        saveToPreferences() // Persistir cambios&#10;        Log.d(TAG, &quot;️ Carrito limpiado&quot;)&#10;    }&#10;&#10;    fun isEmpty(): Boolean {&#10;        return items.isEmpty()&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package app.src.utils&#13;&#10;&#13;&#10;import android.content.Context&#13;&#10;import android.content.SharedPreferences&#13;&#10;import android.util.Log&#13;&#10;import app.src.data.models.Producto&#13;&#10;import com.google.gson.Gson&#13;&#10;import com.google.gson.reflect.TypeToken&#13;&#10;import kotlinx.coroutines.flow.MutableStateFlow&#13;&#10;import kotlinx.coroutines.flow.StateFlow&#13;&#10;import kotlinx.coroutines.flow.asStateFlow&#13;&#10;&#13;&#10;/**&#13;&#10; * CartManager - Gestión del Carrito de Compras con Persistencia&#13;&#10; *&#13;&#10; * Características:&#13;&#10; * - ✅ StateFlow para badge en tiempo real&#13;&#10; * - Almacenamiento en memoria (rápido) + SharedPreferences (persistente)&#13;&#10; * - El carrito NO se pierde al cerrar la app&#13;&#10; * - Sincronización automática entre memoria y disco&#13;&#10; * - Thread-safe para operaciones concurrentes&#13;&#10; */&#13;&#10;object CartManager {&#13;&#10;&#13;&#10;    private const val TAG = &quot;CartManager&quot;&#13;&#10;    private const val PREFS_NAME = &quot;CartPreferences&quot;&#13;&#10;    private const val KEY_CART_ITEMS = &quot;cart_items&quot;&#13;&#10;&#13;&#10;    private val gson = Gson()&#13;&#10;    private var context: Context? = null&#13;&#10;&#13;&#10;    data class CartItem(&#13;&#10;        val producto: Producto,&#13;&#10;        var cantidad: Int = 1&#13;&#10;    ) {&#13;&#10;        val subtotal: Double&#13;&#10;            get() = producto.precio * cantidad&#13;&#10;    }&#13;&#10;&#13;&#10;    // Cache en memoria para acceso rápido&#13;&#10;    private val items = mutableMapOf&lt;Int, CartItem&gt;()&#13;&#10;&#13;&#10;    // ✅ StateFlow para Cart Badge - actualizaciones en tiempo real&#13;&#10;    private val _itemCountFlow = MutableStateFlow(0)&#13;&#10;    val itemCountFlow: StateFlow&lt;Int&gt; = _itemCountFlow.asStateFlow()&#13;&#10;&#13;&#10;    private val _totalFlow = MutableStateFlow(0.0)&#13;&#10;    val totalFlow: StateFlow&lt;Double&gt; = _totalFlow.asStateFlow()&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Inicializa el CartManager con el contexto de la aplicación&#13;&#10;     * Debe llamarse al inicio de la app (en Application o Activity principal)&#13;&#10;     */&#13;&#10;    fun init(appContext: Context) {&#13;&#10;        context = appContext.applicationContext&#13;&#10;        loadFromPreferences()&#13;&#10;        updateFlows()&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Carga el carrito desde SharedPreferences al iniciar&#13;&#10;     */&#13;&#10;    private fun loadFromPreferences() {&#13;&#10;        try {&#13;&#10;            val prefs = getPreferences() ?: return&#13;&#10;            val json = prefs.getString(KEY_CART_ITEMS, null) ?: return&#13;&#10;&#13;&#10;            val type = object : TypeToken&lt;Map&lt;Int, CartItem&gt;&gt;() {}.type&#13;&#10;            val loadedItems: Map&lt;Int, CartItem&gt; = gson.fromJson(json, type)&#13;&#10;&#13;&#10;            items.clear()&#13;&#10;            items.putAll(loadedItems)&#13;&#10;&#13;&#10;            Log.d(TAG, &quot;✅ Carrito cargado desde persistencia: ${items.size} items&quot;)&#13;&#10;        } catch (e: Exception) {&#13;&#10;            Log.e(TAG, &quot;❌ Error al cargar carrito: ${e.message}&quot;)&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Guarda el carrito en SharedPreferences&#13;&#10;     */&#13;&#10;    private fun saveToPreferences() {&#13;&#10;        try {&#13;&#10;            val prefs = getPreferences() ?: return&#13;&#10;            val json = gson.toJson(items)&#13;&#10;&#13;&#10;            prefs.edit().putString(KEY_CART_ITEMS, json).apply()&#13;&#10;            Log.d(TAG, &quot; Carrito guardado en persistencia&quot;)&#13;&#10;        } catch (e: Exception) {&#13;&#10;            Log.e(TAG, &quot;❌ Error al guardar carrito: ${e.message}&quot;)&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * ✅ Actualiza los StateFlows para que el UI se entere de cambios&#13;&#10;     */&#13;&#10;    private fun updateFlows() {&#13;&#10;        _itemCountFlow.value = getItemCount()&#13;&#10;        _totalFlow.value = getTotal()&#13;&#10;    }&#13;&#10;&#13;&#10;    private fun getPreferences(): SharedPreferences? {&#13;&#10;        return context?.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#13;&#10;    }&#13;&#10;&#13;&#10;    fun addProduct(producto: Producto, cantidad: Int = 1) {&#13;&#10;        val existing = items[producto.id]&#13;&#10;        if (existing != null) {&#13;&#10;            existing.cantidad += cantidad&#13;&#10;        } else {&#13;&#10;            items[producto.id] = CartItem(producto, cantidad)&#13;&#10;        }&#13;&#10;        saveToPreferences()&#13;&#10;        updateFlows() // ✅ Notificar cambios&#13;&#10;        Log.d(TAG, &quot;➕ Producto agregado: ${producto.nombre} (cantidad: $cantidad)&quot;)&#13;&#10;    }&#13;&#10;&#13;&#10;    fun removeProduct(productoId: Int) {&#13;&#10;        items.remove(productoId)&#13;&#10;        saveToPreferences()&#13;&#10;        updateFlows() // ✅ Notificar cambios&#13;&#10;        Log.d(TAG, &quot;➖ Producto eliminado: ID $productoId&quot;)&#13;&#10;    }&#13;&#10;&#13;&#10;    fun clear() {&#13;&#10;        items.clear()&#13;&#10;        saveToPreferences()&#13;&#10;        updateFlows() // ✅ Notificar cambios&#13;&#10;        Log.d(TAG, &quot;️ Carrito limpiado&quot;)&#13;&#10;    }&#13;&#10;&#13;&#10;    fun getItems(): List&lt;CartItem&gt; = items.values.toList()&#13;&#10;&#13;&#10;    fun getItemCount(): Int = items.values.sumOf { it.cantidad }&#13;&#10;&#13;&#10;    fun getTotal(): Double = items.values.sumOf { it.subtotal }&#13;&#10;&#13;&#10;    fun isEmpty(): Boolean = items.isEmpty()&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/compile_install.bat">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/compile_install.bat" />
              <option name="updatedContent" value="@echo off&#10;echo Compilando e instalando la aplicacion...&#10;call gradlew.bat installDebug&#10;echo.&#10;echo Compilacion completada!&#10;pause&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>